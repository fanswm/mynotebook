Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2017-12-11T16:39:31+08:00

====== 2 文件系统的简单操作 ======
Created Monday 11 December 2017

2. 文件系统的简单操作
　　2.1 磁盘与目录的容量： df, du
　　2.2 实体链接与符号链接： ln
文件系统的简单操作

__磁盘与目录的容量：__

__df：列出文件系统的整体磁盘使用量；__
__du：评估文件系统的磁盘使用量(常用在推估目录所占容量)__

__df__
__[root@www ~]# df [-ahikHTm] [目录或文件名]__
__选项与参数：__
__-a  ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；__
__-k  ：以 KBytes 的容量显示各文件系统；__
__-m  ：以 MBytes 的容量显示各文件系统；__
__-h  ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；__
__-H  ：以 M=1000K 取代 M=1024K 的进位方式；__
__-T  ：连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；__
__-i  ：不用硬盘容量，而以 inode 的数量来显示__

范例一：将系统内所有的 filesystem 列出来！
[root@www ~]# df
Filesystem      1K-blocks      Used Available Use% Mounted on
/dev/hdc2         9920624   3823112   5585444  41% /
/dev/hdc3         4956316    141376   4559108   4% /home
/dev/hdc1          101086     11126     84741  12% /boot
tmpfs              371332         0    371332   0% /dev/shm
# 在 Linux 底下如果 df 没有加任何选项，那么默认会将系统内所有的 
# (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！
# 至于那个 /dev/shm 是与内存有关的挂载，先不要理他！

范例二：将容量结果以易读的容量格式显示出来
[root@www ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/hdc2             9.5G  3.7G  5.4G  41% /
/dev/hdc3             4.8G  139M  4.4G   4% /home
/dev/hdc1              99M   11M   83M  12% /boot
tmpfs                 363M     0  363M   0% /dev/shm
# 不同于范例一，这里会以 G/M 等容量格式显示出来，比较容易看啦！

范例三：__将系统内的所有特殊文件格式及名称都列出来__
[root@www ~]# df -aT
Filesystem    Type 1K-blocks    Used Available Use% Mounted on
/dev/hdc2     ext3   9920624 3823112   5585444  41% /
proc          proc         0       0         0   -  /proc
sysfs        sysfs         0       0         0   -  /sys
devpts      devpts         0       0         0   -  /dev/pts
/dev/hdc3     ext3   4956316  141376   4559108   4% /home
/dev/hdc1     ext3    101086   11126     84741  12% /boot
tmpfs        tmpfs    371332       0    371332   0% /dev/shm
none   binfmt_misc         0       0         0   -  /proc/sys/fs/binfmt_misc
sunrpc  rpc_pipefs         0       0         0   -  /var/lib/nfs/rpc_pipefs
# 系统里面其实还有很多特殊的文件系统存在的。__那些比较特殊的文件系统几乎__
__# 都是在内存当中__，例如 /proc 这个挂载点。因此，这些特殊的文件系统
# 都不会占据硬盘空间喔！ ^_^

__范例四：将 /etc 底下的可用的磁盘容量以易读的容量格式显示__
__[root@www ~]# df -h /etc__
Filesystem            Size  Used Avail Use% Mounted on
/dev/hdc2             9.5G  3.7G  5.4G  41% /
# 这个范例比较有趣一点啦，在 df 后面加上目录或者是文件时， df
# 会自动的分析该目录或文件所在的 partition ，并将该 partition 的容量显示出来，
# 所以，您就可以知道某个目录底下还有多少容量可以使用了！ ^_^

范例五：将目前各个 partition 当中可用的 inode 数量列出
[root@www ~]# df -ih 
Filesystem            Inodes   IUsed   IFree IUse% Mounted on
/dev/hdc2               2.5M    147K    2.3M    6% /
/dev/hdc3               1.3M      46    1.3M    1% /home
/dev/hdc1                26K      34     26K    1% /boot
tmpfs                    91K       1     91K    1% /dev/shm
# 这个范例则主要列出可用的 inode 剩余量与总容量。分析一下与范例一的关系，
# 你可以清楚的发现到，通常 inode 的数量剩余都比 block 还要多呢
先来说明一下范例一所输出的结果信息为：

__Filesystem：代表该文件系统是在哪个 partition ，所以列出装置名称；__
__1k-blocks：说明底下的数字单位是 1KB 呦！可利用 -h 或 -m 来改变容量；__
__Used：顾名思义，就是使用掉的硬盘空间啦！__
__Available：也就是剩下的磁盘空间大小；__
__Use%：就是磁盘的使用率啦！如果使用率高达 90% 以上时， 最好需要注意一下了__，免得容量不足造成系统问题喔！(例如最容易被灌爆的 /var/spool/mail 这个放置邮件的磁盘)
__Mounted on：就是磁盘挂载的目录所在啦！(挂载点啦！)__
由于 df 主要读取的数据几乎都是针对一整个文件系统，因此读取的范围主要是在 Superblock 内的信息， 所以这个命令显示结果的速度非常的快速！在显示的结果中你需要特别留意的是那个根目录的剩余容量！ 因为我们所有的数据都是由根目录衍生出来的，因此当根目录的剩余容量剩下 0 时，那你的 Linux 可能就问题很大了。

Tips:
说个陈年老笑话！鸟哥还在念书时，别的研究室有个管理 Sun 工作站的研究生发现， 他的硬盘明明还有好几 GB ，但是就是没有办法将光盘内几 MB 的数据 copy 进去， 他就去跟老板讲说机器坏了！嘿！明明才来维护过几天而已为何会坏了！ 结果他老板就将维护商叫来骂了 2 小时左右吧！

后来，维护商发现原来硬盘的『总空间』还有很多， 只是某个分割槽填满了，偏偏该研究生就是要将数据 copy 去那个分割槽！呵呵！ 后来那个研究生就被命令『再也不许碰 Sun 主机』了～～	鸟哥的图示
另外需要注意的是，如果使用 -a 这个参数时，系统会出现 /proc 这个挂载点，但是里面的东西都是 0 ，不要紧张！ /proc 的东西都是 Linux 系统所需要加载的系统数据，而且是挂载在『内存当中』的， 所以当然没有占任何的硬盘空间啰！

至于那个 __/dev/shm/ 目录，其实是利用内存虚拟出来的磁盘空间__！ 由于是透过内存仿真出来的磁盘，因此你在这个目录底下创建任何数据文件时，访问速度是非常快速的！(在内存内工作) 不过，也由于他是内存仿真出来的，因此这个文件系统的大小在每部主机上都不一样，而且创建的东西在下次启动时就消失了！ 因为是在内存中嘛！


__du__
__[root@www ~]# du [-ahskm] 文件或目录名称__
__选项与参数：__
__-a  ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。__
__-h  ：以人们较易读的容量格式 (G/M) 显示；__
__-s  ：列出总量而已，而不列出每个各别的目录占用容量；__
__-S  ：不包括子目录下的总计，与 -s 有点差别。__
__-k  ：以 KBytes 列出容量显示；__
__-m  ：以 MBytes 列出容量显示；__

范例一：列出目前目录下的所有文件容量
[root@www ~]# du
8       ./test4     <==每个目录都会列出来
8       ./test2
....中间省略....
12      ./.gconfd   <==包括隐藏文件的目录
220     .           <==这个目录(.)所占用的总量
# 直接输入 du 没有加任何选项时，则 du 会分析『目前所在目录』
# 的文件与目录所占用的硬盘空间。但是，实际显示时，仅会显示目录容量(不含文件)，
# 因此 . 目录有很多文件没有被列出来，所以全部的目录相加不会等于 . 的容量喔！
# 此外，输出的数值数据为 1K 大小的容量单位。

范例二：同范例一，但是将文件的容量也列出来
[root@www ~]# du -a
12      ./install.log.syslog   <==有文件的列表了
8       ./.bash_logout
8       ./test4
8       ./test2
....中间省略....
12      ./.gconfd
220     .

__范例三：检查根目录底下每个目录所占用的容量__
__[root@www ~]# du -sm /*__
7       /bin
6       /boot
.....中间省略....
0       /proc
.....中间省略....
1       /tmp
3859    /usr     <==系统初期最大就是他了啦！
77      /var
# 这是个很常被使用的功能～利用通配符 * 来代表每个目录，
# 如果想要检查某个目录下，哪个次目录占用最大的容量，可以用这个方法找出来
# 值得注意的是，如果刚刚安装好 Linux 时，那么整个系统容量最大的应该是 /usr 
# 而 /proc 虽然有列出容量，但是那个容量是在内存中，不占硬盘空间。
与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据， 所以上述第三个范例命令的运行会运行一小段时间！此外，在默认的情况下，容量的输出是以 KB 来设计的， 如果你想要知道目录占了多少 MB ，那么就使用 -m 这个参数即可啰！而， 如果你只想要知道该目录占了多少容量的话，使用 -s 就可以啦！

至于 -S 这个选项部分，由于 du 默认会将所有文件的大小均列出，因此假设你在 /etc 底下使用 du 时， 所有的文件大小，包括 /etc 底下的次目录容量也会被计算一次。然后最终的容量 (/etc) 也会加总一次， 因此很多朋友都会误会 du 分析的结果不太对劲。所以啰，如果想要列出某目录下的全部数据， 或许也可以加上 -S 的选项，减少次目录的加总喔！

实体链接与符号链接： ln
关于链接(link)数据我们第六章的Linux文件属性及Linux文件种类与扩展名当中提过一些信息， 不过当时由于尚未讲到文件系统，因此无法较完整的介绍连结档啦。不过在上一小节谈完了文件系统后， 我们可以来了解一下连结档这玩意儿了。

在 Linux 底下的连结档有两种，一种是类似 Windows 的快捷方式功能的文件，可以让你快速的链接到目标文件(或目录)； 另一种则是透过文件系统的 inode 连结来产生新档名，而不是产生新文件！这种称为实体链接 (hard link)。 这两种玩意儿是完全不一样的东西呢！现在就分别来谈谈。


Hard Link (实体链接, 硬式连结或实际连结)
在前一小节当中，我们知道几件重要的信息，包括：

每个文件都会占用一个 inode ，文件内容由 inode 的记录来指向；
想要读取该文件，必须要经过目录记录的文件名来指向到正确的 inode 号码才能读取。
也就是说，其实文件名只与目录有关，但是文件内容则与 inode 有关。那么想一想， 有没有可能有多个档名对应到同一个 inode 号码呢？有的！那就是 hard link 的由来。 所以简单的说：hard link 只是在某个目录下新增一笔档名链接到某 inode 号码的关连记录而已。

举个例子来说，假设我系统有个 /root/crontab 他是 /etc/crontab 的实体链接，也就是说这两个档名连结到同一个 inode ， 自然这两个文件名的所有相关信息都会一模一样(除了文件名之外)。实际的情况可以如下所示：

[root@www ~]# ln /etc/crontab .   <==创建实体链接的命令
[root@www ~]# ll -i /etc/crontab /root/crontab
1912701 -rw-r--r-- 2 root root 255 Jan  6  2007 /etc/crontab
1912701 -rw-r--r-- 2 root root 255 Jan  6  2007 /root/crontab
你可以发现两个档名都连结到 1912701 这个 inode 号码，所以您瞧瞧，是否文件的权限/属性完全一样呢？ 因为这两个『档名』其实是一模一样的『文件』啦！而且你也会发现第二个字段由原本的 1 变成 2 了！ 那个字段称为『连结』，这个字段的意义为：『有多少个档名链接到这个 inode 号码』的意思。 如果将读取到正确数据的方式画成示意图，就类似如下画面：

实体链接的文件读取示意图
图 2.2.1、实体链接的文件读取示意图
上图的意思是，你可以透过 1 或 2 的目录之 inode 指定的 block 找到两个不同的档名，而不管使用哪个档名均可以指到 real 那个 inode 去读取到最终数据！那这样有什么好处呢？最大的好处就是『安全』！如同上图中， 如果你将任何一个『档名』删除，其实 inode 与 block 都还是存在的！ 此时你可以透过另一个『档名』来读取到正确的文件数据喔！此外，不论你使用哪个『档名』来编辑， 最终的结果都会写入到相同的 inode 与 block 中，因此均能进行数据的修改哩！

一般来说，使用 hard link 配置链接文件时，磁盘的空间与 inode 的数目都不会改变！ 我们还是由图 2.2.1 来看，由图中可以知道， hard link 只是在某个目录下的 block 多写入一个关连数据而已，既不会添加 inode 也不会耗用 block 数量哩！

Tips:
hard link 的制作中，其实还是可能会改变系统的 block 的，那就是当你新增这笔数据却刚好将目录的 block 填满时，就可能会新加一个 block 来记录文件名关连性，而导致磁盘空间的变化！不过，一般 hard link 所用掉的关连数据量很小，所以通常不会改变 inode 与磁盘空间的大小喔！	鸟哥的图示
由图 2.2.1 其实我们也能够知道，事实上 hard link 应该仅能在单一文件系统中进行的，应该是不能够跨文件系统才对！ 因为图 2.2.1 就是在同一个 filesystem 上嘛！所以 hard link 是有限制的：

不能跨 Filesystem；
不能 link 目录。
不能跨 Filesystem 还好理解，那不能 hard link 到目录又是怎么回事呢？这是因为如果使用 hard link 链接到目录时， 链接的数据需要连同被链接目录底下的所有数据都创建链接，举例来说，如果你要将 /etc 使用实体链接创建一个 /etc_hd 的目录时，那么在 /etc_hd 底下的所有档名同时都与 /etc 底下的檔名要创建 hard link 的，而不是仅连结到 /etc_hd 与 /etc 而已。 并且，未来如果需要在 /etc_hd 底下创建新文件时，连带的， /etc 底下的数据又得要创建一次 hard link ，因此造成环境相当大的复杂度。 所以啰，目前 hard link 对于目录暂时还是不支持的啊！


Symbolic Link (符号链接，亦即是快捷方式)
相对于 hard link ， Symbolic link 可就好理解多了，基本上， Symbolic link 就是在创建一个独立的文件，而这个文件会让数据的读取指向他 link 的那个文件的档名！由于只是利用文件来做为指向的动作， 所以，当来源档被删除之后，symbolic link 的文件会『开不了』， 会一直说『无法开启某文件！』。实际上就是找不到原始『档名』而已啦！

举例来说，我们先创建一个符号链接文件链接到 /etc/crontab 去看看：

[root@www ~]# ln -s /etc/crontab crontab2
[root@www ~]# ll -i /etc/crontab /root/crontab2
1912701 -rw-r--r-- 2 root root 255 Jan  6  2007 /etc/crontab
 654687 lrwxrwxrwx 1 root root  12 Oct 22 13:58 /root/crontab2 -> /etc/crontab
由上表的结果我们可以知道两个文件指向不同的 inode 号码，当然就是两个独立的文件存在！ 而且连结档的重要内容就是他会写上目标文件的『文件名』， 你可以发现为什么上表中连结档的大小为 12 bytes 呢？ 因为箭头(-->)右边的档名『/etc/crontab』总共有 12 个英文，每个英文占用 1 个 byes ，所以文件大小就是 12bytes了！

关于上述的说明，我们以如下图示来解释：

符号链接的文件读取示意图
图 2.2.2、符号链接的文件读取示意图
由 1 号 inode 读取到连结档的内容仅有档名，根据档名链接到正确的目录去取得目标文件的 inode ， 最终就能够读取到正确的数据了。你可以发现的是，如果目标文件(/etc/crontab)被删除了，那么整个环节就会无法继续进行下去， 所以就会发生无法透过连结档读取的问题了！

这里还是得特别留意，这个 Symbolic Link 与 Windows 的快捷方式可以给他划上等号，由 Symbolic link 所创建的文件为一个独立的新的文件，所以会占用掉 inode 与 block 喔！


由上面的说明来看，似乎 hard link 比较安全，因为即使某一个目录下的关连数据被杀掉了， 也没有关系，只要有任何一个目录下存在着关连数据，那么该文件就不会不见！举上面的例子来说，我的 /etc/crontab 与 /root/crontab 指向同一个文件，如果我删除了 /etc/crontab 这个文件，该删除的动作其实只是将 /etc 目录下关于 crontab 的关连数据拿掉而已， crontab 所在的 inode 与 block 其实都没有被变动喔！

不过由于 Hard Link 的限制太多了，包括无法做『目录』的 link ， 所以在用途上面是比较受限的！反而是 Symbolic Link 的使用方面较广喔！好了， 说的天花乱坠，看你也差不多快要昏倒了！没关系，实作一下就知道怎么回事了！要制作连结档就必须要使用 ln 这个命令呢！

 [root@www ~]# ln [-sf] 来源文件 目标文件
选项与参数：
-s  ：如果不加任何参数就进行连结，那就是hard link，至于 -s 就是symbolic link
-f  ：如果 目标文件 存在时，就主动的将目标文件直接移除后再创建！

范例一：将 /etc/passwd 复制到 /tmp 底下，并且观察 inode 与 block
[root@www ~]# cd /tmp
[root@www tmp]# cp -a /etc/passwd .
[root@www tmp]# du -sb ; df -i .
18340   .  <==先注意一下这里的容量是多少！
Filesystem            Inodes   IUsed   IFree IUse% Mounted on
/dev/hdc2            2560864  149738 2411126    6% /
# 利用 du 与 df 来检查一下目前的参数～那个 du -sb 
# 是计算整个 /tmp 底下有多少 bytes 的容量啦！

范例二：将 /tmp/passwd 制作 hard link 成为 passwd-hd 文件，并观察文件与容量
[root@www tmp]# ln passwd passwd-hd
[root@www tmp]# du -sb ; df -i .
18340   .
Filesystem            Inodes   IUsed   IFree IUse% Mounted on
/dev/hdc2            2560864  149738 2411126    6% /
# 仔细看，即使多了一个文件在 /tmp 底下，整个 inode 与 block 的容量并没有改变！

[root@www tmp]# ls -il passwd*
586361 -rw-r--r-- 2 root root 1945 Sep 29 02:21 passwd
586361 -rw-r--r-- 2 root root 1945 Sep 29 02:21 passwd-hd
# 原来是指向同一个 inode 啊！这是个重点啊！另外，那个第二栏的连结数也会添加！

范例三：将 /tmp/passwd 创建一个符号链接
[root@www tmp]# ln -s passwd passwd-so
[root@www tmp]# ls -li passwd*
586361 -rw-r--r-- 2 root root 1945 Sep 29 02:21 passwd
586361 -rw-r--r-- 2 root root 1945 Sep 29 02:21 passwd-hd
586401 lrwxrwxrwx 1 root root    6 Oct 22 14:18 passwd-so -> passwd
# passwd-so 指向的 inode number 不同了！这是一个新的文件～这个文件的内容是指向 
# passwd 的。passwd-so 的大小是 6bytes ，因为 passwd 共有六个字符之故

[root@www tmp]# du -sb ; df -i .
18346   .
Filesystem            Inodes   IUsed   IFree IUse% Mounted on
/dev/hdc2            2560864  149739 2411125    6% /
# 呼呼！整个容量与 inode 使用数都改变啰～确实如此啊！

范例四：删除源文件 passwd ，其他两个文件是否能够开启？
[root@www tmp]# rm passwd
[root@www tmp]# cat passwd-hd
......正常显示完毕！
[root@www tmp]# cat passwd-so
cat: passwd-so: No such file or directory
[root@www tmp]# ll passwd*
-rw-r--r-- 1 root root 1945 Sep 29 02:21 passwd-hd
lrwxrwxrwx 1 root root    6 Oct 22 14:18 passwd-so -> passwd
# 怕了吧！符号链接果然无法开启！另外，如果符号链接的目标文件不存在，
# 其实档名的部分就会有特殊的颜色显示喔！
Tips:
还记得第六章当中，我们提到的 /tmp 这个目录是干嘛用的吗？是给大家作为缓存盘用的啊！ 所以，您会发现，过去我们在进行测试时，都会将数据移动到 /tmp 底下去练习～ 嘿嘿！因此，有事没事，记得将 /tmp 底下的一些怪异的数据清一清先！	鸟哥的图示
要注意啰！使用 ln 如果不加任何参数的话，那么就是 Hard Link 啰！如同范例二的情况，添加了 hard link 之后，可以发现使用 ls -l 时，显示的 link 那一栏属性添加了！而如果这个时候砍掉 passwd 会发生什么事情呢？passwd-hd 的内容还是会跟原来 passwd 相同，但是 passwd-so 就会找不到该文件啦！

而如果 ln 使用 -s 的参数时，就做成差不多是 Windows 底下的『快捷方式』的意思。当你修改 Linux 下的 symbolic link 文件时，则更动的其实是『原始档』， 所以不论你的这个原始档被连结到哪里去，只要你修改了连结档，原始档就跟着变啰！ 以上面为例，由于你使用 -s 的参数创建一个名为 passwd-so 的文件，则你修改 passwd-so 时，其内容与 passwd 完全相同，并且，当你按下储存之后，被改变的将是 passwd 这个文件！

此外，如果你做了底下这样的连结：

ln -s /bin /root/bin
那么如果你进入 /root/bin 这个目录下，『请注意呦！该目录其实是 /bin 这个目录，因为你做了连结档了！』所以，如果你进入 /root/bin 这个刚刚创建的链接目录， 并且将其中的数据杀掉时，嗯！ /bin 里面的数据就通通不见了！这点请千万注意！所以赶紧利用『rm /root/bin 』 将这个连结档删除吧！

基本上， Symbolic link 的用途比较广，所以您要特别留意 symbolic link 的用法呢！未来一定还会常常用到的啦！


关于目录的 link 数量：
或许您已经发现了，那就是，当我们以 hard link 进行『文件的连结』时，可以发现，在 ls -l 所显示的第二字段会添加一才对，那么请教，如果创建目录时，他默认的 link 数量会是多少？ 让我们来想一想，一个『空目录』里面至少会存在些什么？呵呵！就是存在 . 与 .. 这两个目录啊！ 那么，当我们创建一个新目录名称为 /tmp/testing 时，基本上会有三个东西，那就是：

/tmp/testing
/tmp/testing/.
/tmp/testing/..
而其中 /tmp/testing 与 /tmp/testing/. 其实是一样的！都代表该目录啊～而 /tmp/testing/.. 则代表 /tmp 这个目录，所以说，当我们创建一个新的目录时， 『新的目录的 link 数为 2 ，而上一级目录的 link 数则会添加 1 』 不信的话，我们来作个测试看看：

[root@www ~]# ls -ld /tmp
drwxrwxrwt 5 root root 4096 Oct 22 14:22 /tmp
[root@www ~]# mkdir /tmp/testing1
[root@www ~]# ls -ld /tmp
drwxrwxrwt 6 root root 4096 Oct 22 14:37 /tmp
[root@www ~]# ls -ld /tmp/testing1
drwxr-xr-x 2 root root 4096 Oct 22 14:37 /tmp/testing1
瞧！原本的所谓上一级目录 /tmp 的 link 数量由 5 添加为 6 ，至于新目录 /tmp/testing 则为 2 ，这样可以理解目录的 link 数量的意义了吗？ ^_^
