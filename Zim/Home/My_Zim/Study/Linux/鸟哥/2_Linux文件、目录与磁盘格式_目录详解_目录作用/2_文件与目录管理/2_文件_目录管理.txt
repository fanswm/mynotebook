Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2017-12-11T16:37:32+08:00

====== 2 文件 目录管理 ======
Created Monday 11 December 2017

文件与目录管理：
谈了谈目录与路径之后，再来讨论一下关於文件的一些基本管理吧！文件与目录的管理上，不外乎『显示属性』、 『拷贝』、『删除文件』及『移动文件或目录』等等，由於文件与目录的管理在 Linux 当中是很重要的， 尤其是每个人自己家目录的数据也都需要注意管理！所以我们来谈一谈有关文件与目录的一些基础管理部分吧！


文件与目录的检视： ls
[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称
[root@www ~]# ls [--color={never,auto,always}] 目录名称
__[root@www ~]# ls [--full-time] 目录名称__
选项与参数：
__-a  ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)__
-A  ：全部的文件，连同隐藏档，但不包括 . 与 .. 这两个目录
__-d  ：仅列出目录本身，而不是列出目录内的文件数据(常用)__
-f  ：直接列出结果，而不进行排序 (ls 默认会以档名排序！)
-F  ：根据文件、目录等资讯，给予附加数据结构，例如：
      __*:代表可运行档； /:代表目录； =:代表 socket 文件； |:代表 FIFO 文件；__
-h  ：将文件容量以人类较易读的方式(例如 GB, KB 等等)列出来；
-i  ：列出 inode 号码，inode 的意义下一章将会介绍；
__-l  ：长数据串列出，包含文件的属性与权限等等数据；(常用)__
-n  ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在帐号管理提到！)
-r  ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小；
-R  ：连同子目录内容一起列出来，等於该目录下的所有文件都会显示出来；
-S  ：以文件容量大小排序，而不是用档名排序；
-t  ：依时间排序，而不是用档名。
--color=never  ：不要依据文件特性给予颜色显示；
--color=always ：显示颜色
--color=auto   ：让系统自行依据配置来判断是否给予颜色
--full-time    ：以完整时间模式 (包含年、月、日、时、分) 输出
--time={atime,ctime} ：输出 access 时间或改变权限属性时间 (ctime) 
                       而非内容变更时间 (modification time)

在Linux系统当中，这个 ls 命令可能是最常被运行的吧！因为我们随时都要知道文件或者是目录的相关资讯啊～ 不过，我们Linux的文件所记录的资讯实在是太多了，ls 没有需要全部都列出来呢～ 所以，当你只有下达 ls 时，默认显示的只有：非隐藏档的档名、 以档名进行排序及档名代表的颜色显示如此而已。举例来说， 你下达『 ls /etc 』之后，只有经过排序的档名以及以蓝色显示目录及白色显示一般文件，如此而已。

那如果我还想要加入其他的显示资讯时，可以加入上头提到的那些有用的选项呢～ 举例来说，我们之前一直用到的 -l 这个长串显示数据内容，以及将隐藏档也一起列示出来的 -a 选项等等。 底下则是一些常用的范例，实际试做看看：


范例二：承上题，不显示颜色，但在档名末显示出该档名代表的类型(type)
[root@www ~]# ls -alF --color=never  ~
total 156
drwxr-x---  4 root root  4096 Sep 24 00:07 ./
drwxr-xr-x 23 root root  4096 Sep 22 12:09 ../
-rw-------  1 root root  1474 Sep  4 18:27 anaconda-ks.cfg
-rw-------  1 root root   955 Sep 24 00:08 .bash_history
-rw-r--r--  1 root root    24 Jan  6  2007 .bash_logout
-rw-r--r--  1 root root   191 Jan  6  2007 .bash_profile
-rw-r--r--  1 root root   176 Jan  6  2007 .bashrc
drwx------  3 root root  4096 Sep  5 10:37 .gconf/
-rw-r--r--  1 root root 42304 Sep  4 18:26 install.log
-rw-r--r--  1 root root  5661 Sep  4 18:25 install.log.syslog
# 注意看到显示结果的第一行，嘿嘿～知道为何我们会下达类似 ./command 
# 之类的命令了吧？因为 ./ 代表的是『目前目录下』的意思啊！至於什么是 FIFO/Socket ？
# 请参考前一章节的介绍啊！另外，那个.bashrc 时间仅写2007，能否知道详细时间？

范例三：__完整的呈现文件的修改时间 *(modification time)__
__[root@www ~]# ls -al --full-time  ~__
total 156
drwxr-x---  4 root root  4096 2008-09-24 00:07:00.000000 +0800 .
drwxr-xr-x 23 root root  4096 2008-09-22 12:09:32.000000 +0800 ..
-rw-------  1 root root  1474 2008-09-04 18:27:10.000000 +0800 anaconda-ks.cfg
-rw-------  1 root root   955 2008-09-24 00:08:14.000000 +0800 .bash_history
-rw-r--r--  1 root root    24 2007-01-06 17:05:04.000000 +0800 .bash_logout
-rw-r--r--  1 root root   191 2007-01-06 17:05:04.000000 +0800 .bash_profile
-rw-r--r--  1 root root   176 2007-01-06 17:05:04.000000 +0800 .bashrc
drwx------  3 root root  4096 2008-09-05 10:37:49.000000 +0800 .gconf
-rw-r--r--  1 root root 42304 2008-09-04 18:26:57.000000 +0800 install.log
-rw-r--r--  1 root root  5661 2008-09-04 18:25:55.000000 +0800 install.log.syslog
# 请仔细看，上面的『时间』栏位变了喔！变成较为完整的格式。
# 一般来说， ls -al 仅列出目前短格式的时间，有时不会列出年份，
# 藉由 --full-time 可以查阅到比较正确的完整时间格式啊！
其实 ls 的用法还有很多，包括查阅文件所在 i-node 号码的 ls -i 选项，以及用来进行文件排序的 -S 选项，还有用来查阅不同时间的动作的 --time=atime 等选项(更多时间说明请参考本章后面touch的说明)。而这些选项的存在都是因为 Linux 文件系统记录了很多有用的资讯的缘故。那么 Linux 的文件系统中，这些与权限、属性有关的数据放在哪里呢？ 放在 i-node 里面。关於这部分，我们会在下一章继续为你作比较深入的介绍啊！

无论如何， ls 最常被使用到的功能还是那个 -l 的选项，为此，很多 distribution 在默认的情况中， 已经将 ll (L 的小写) 配置成为 ls -l 的意思了！其实，那个功能是 Bash shell 的 alias 功能呢～也就是说，我们直接输入 ll 就等於是输入 ls -l 是一样的～关於这部分，我们会在后续 bash shell 时再次的强调滴～

复制、删除与移动： cp, rm, mv
要复制文件，请使用 cp (copy) 这个命令即可～不过， cp 这个命令的用途可多了～ 除了单纯的复制之外，还可以创建连结档 (就是捷径罗)，比对两文件的新旧而予以升级， 以及复制整个目录等等的功能呢！至於移动目录与文件，则使用 mv (move)， 这个命令也可以直接拿来作更名 (rename) 的动作喔！至於移除吗？那就是 rm (remove) 这个命令罗～底下我们就来瞧一瞧先～


__cp (复制文件或目录)__
__[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)__
__[root@www ~]# cp [options] source1 source2 source3 .... directory__
选项与参数：
__-a  ：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)__
__-d  ：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；__
-f  ：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；
__-i  ：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)__
-l  ：进行硬式连结(hard link)的连结档创建，而非复制文件本身；
__-p  ：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；__
__-r  ：递回持续复制，用於目录的复制行为；(常用)__
-s  ：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；
-u  ：若 destination 比 source 旧才升级 destination ！

最后需要注意的，__如果来源档有两个以上，则最后一个目的档一定要是『目录』才行！__
复制(cp)这个命令是非常重要的，不同身份者运行这个命令会有不同的结果产生，尤其是那个-a, -p的选项， 对於不同身份来说，差异则非常的大！底下的练习中，有的身份为root有的身份为一般帐号(在我这里用vbird这个帐号)， 练习时请特别注意身份的差别喔！好！开始来做复制的练习与观察：

范例一：用root身份，将家目录下的 .bashrc 复制到 /tmp 下，并更名为 bashrc
[root@www ~]# cp ~/.bashrc /tmp/bashrc
[root@www ~]# cp -i ~/.bashrc /tmp/bashrc
cp: overwrite `/tmp/bashrc'? n  <==n不覆盖，y为覆盖
# 重复作两次动作，由於 /tmp 底下已经存在 bashrc 了，加上 -i 选项后，
# 则在覆盖前会询问使用者是否确定！可以按下 n 或者 y 来二次确认呢！

范例二：变换目录到/tmp，并将/var/log/wtmp复制到/tmp且观察属性：
[root@www ~]# cd /tmp
[root@www tmp]# cp /var/log/wtmp . <==想要复制到目前的目录，最后的 . 不要忘
[root@www tmp]# ls -l /var/log/wtmp wtmp
-rw-rw-r-- 1 root utmp 96384 Sep 24 11:54 /var/log/wtmp
-rw-r--r-- 1 root root 96384 Sep 24 14:06 wtmp
# 注意上面的特殊字体，在不加任何选项的情况下，文件的某些属性/权限会改变；
# 这是个很重要的特性！要注意喔！还有，连文件创建的时间也不一样了！
# 那如果你想要将文件的所有特性都一起复制过来该怎办？可以加上 -a 喔！如下所示：

[root@www tmp]# cp -a /var/log/wtmp wtmp_2
[root@www tmp]# ls -l /var/log/wtmp wtmp_2
-rw-rw-r-- 1 root utmp 96384 Sep 24 11:54 /var/log/wtmp
-rw-rw-r-- 1 root utmp 96384 Sep 24 11:54 wtmp_2
# 了了吧！整个数据特性完全一模一样ㄟ！真是不赖～这就是 -a 的特性！
这个 cp 的功能很多，由於我们常常会进行一些数据的复制，所以也会常常用到这个命令的。 一般来说，我们如果去复制别人的数据 (当然，该文件你必须要有 read 的权限才行啊！ ^_^) 时， 总是希望复制到的数据最后是我们自己的，所以，在默认的条件中， cp 的来源档与目的档的权限是不同的，目的档的拥有者通常会是命令操作者本身。举例来说， 上面的范例二中，由於我是 root 的身份，因此复制过来的文件拥有者与群组就改变成为 root 所有了！ 这样说，可以明白吗？^_^

由於具有这个特性，因此当我们在进行备份的时候，某些需要特别注意的特殊权限文件， 例如密码档 (/etc/shadow) 以及一些配置档，就不能直接以 cp 来复制，而必须要加上 -a 或者是 -p 等等可以完整复制文件权限的选项才行！另外，如果你想要复制文件给其他的使用者， 也必须要注意到文件的权限(包含读、写、运行以及文件拥有者等等)， 否则，其他人还是无法针对你给予的文件进行修订的动作喔！注意注意！

范例三：复制 /etc/ 这个目录下的所有内容到 /tmp 底下
[root@www tmp]# cp /etc/ /tmp
cp: omitting directory `/etc'   <== 如果是目录则不能直接复制，要加上 -r 的选项
[root@www tmp]# cp -r /etc/ /tmp
# 还是要再次的强调喔！ -r 是可以复制目录，但是，文件与目录的权限可能会被改变
# 所以，也可以利用『 cp -a /etc /tmp 』来下达命令喔！尤其是在备份的情况下！

范例四：将范例一复制的 bashrc 创建一个连结档 (symbolic link)
[root@www tmp]# ls -l bashrc
-rw-r--r-- 1 root root 176 Sep 24 14:02 bashrc  <==先观察一下文件情况
[root@www tmp]# cp -s bashrc bashrc_slink
[root@www tmp]# cp -l bashrc bashrc_hlink
[root@www tmp]# ls -l bashrc*
-rw-r--r-- 2 root root 176 Sep 24 14:02 bashrc  <==与原始文件不太一样了！
-rw-r--r-- 2 root root 176 Sep 24 14:02 bashrc_hlink
lrwxrwxrwx 1 root root   6 Sep 24 14:20 bashrc_slink -> bashrc
范例四可有趣了！使用 -l 及 -s 都会创建所谓的连结档(link file)，但是这两种连结档却有不一样的情况。这是怎么一回事啊？ 那个 __-l 就是所谓的实体连结(hard link)，至於 -s 则是符号连结(symbolic link)，__ 简单来说，bashrc_slink 是一个『捷径』，这个捷径会连结到bashrc去！所以你会看到档名右侧会有个指向(->)的符号！

至於bashrc_hlink文件与bashrc的属性与权限完全一模一样，与尚未进行连结前的差异则是第二栏的link数由1变成2了！ 鸟哥这里先不介绍实体连结，因为实体连结涉及 i-node 的相关知识，我们下一章谈到文件系统(filesystem)时再来讨论这个问题。

范例五：若 ~/.bashrc 比 /tmp/bashrc 新才复制过来
[root@www tmp]# cp -u ~/.bashrc /tmp/bashrc
# 这个 -u 的特性，是在目标文件与来源文件有差异时，才会复制的。
# 所以，比较常被用於『备份』的工作当中喔！ ^_^

范例六：将范例四造成的 bashrc_slink 复制成为 bashrc_slink_1 与bashrc_slink_2
[root@www tmp]# cp bashrc_slink bashrc_slink_1
[root@www tmp]# cp -d bashrc_slink bashrc_slink_2
[root@www tmp]# ls -l bashrc bashrc_slink*
-rw-r--r-- 2 root root 176 Sep 24 14:02 bashrc
lrwxrwxrwx 1 root root   6 Sep 24 14:20 bashrc_slink -> bashrc
-rw-r--r-- 1 root root 176 Sep 24 14:32 bashrc_slink_1       <==与原始文件相同
lrwxrwxrwx 1 root root   6 Sep 24 14:33 bashrc_slink_2 -> bashrc <==是连结档！
# 这个例子也是很有趣喔！原本复制的是连结档，但是却将连结档的实际文件复制过来了
# __也就是说，如果没有加上任何选项时，cp复制的是原始文件，而非连结档的属性！__
# 若要复制连结档的属性，就得要使用 -d 的选项了！如 bashrc_slink_2 所示。

范例七：将家目录的 .bashrc 及 .bash_history 复制到 /tmp 底下
[root@www tmp]# cp ~/.bashrc ~/.bash_history /tmp
# 可以将多个数据一次复制到同一个目录去！最后面一定是目录！
例题：
你能否使用vbird的身份，完整的复制/var/log/wtmp文件到/tmp底下，并更名为vbird_wtmp呢？
答：
实际做看看的结果如下：
[vbird@www ~]$ cp -a /var/log/wtmp /tmp/vbird_wtmp
[vbird@www ~]$ ls -l /var/log/wtmp /tmp/vbird_wtmp
-rw-rw-r-- 1 vbird vbird 96384  9月 24 11:54 /tmp/vbird_wtmp
-rw-rw-r-- 1 root  utmp  96384  9月 24 11:54 /var/log/wtmp
由於vbird的身份并不能随意修改文件的拥有者与群组，因此虽然能够复制wtmp的相关权限与时间等属性， 但是与拥有者、群组相关的，原本vbird身份无法进行的动作，即使加上 -a 选项，也是无法达成完整复制权限的！

总之，由於 cp 有种种的文件属性与权限的特性，所以，在复制时，你必须要清楚的了解到：

是否需要完整的保留来源文件的资讯？
来源文件是否为连结档 (symbolic link file)？
来源档是否为特殊的文件，例如 FIFO, socket 等？
来源档是否为目录？

__rm (移除文件或目录)__
__[root@www ~]# rm [-fir] 文件或目录__
__选项与参数：__
__-f  ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；__
__-i  ：互动模式，在删除前会询问使用者是否动作__
__-r  ：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！__

范例一：将刚刚在 cp 的范例中创建的 bashrc 删除掉！
[root@www ~]# cd /tmp
[root@www tmp]# rm -i bashrc
rm: remove regular file `bashrc'? y
# 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！

范例二：透过万用字节*的帮忙，将/tmp底下开头为bashrc的档名通通删除：
[root@www tmp]# rm -i bashrc*
# 注意那个星号，代表的是 0 到无穷多个任意字节喔！很好用的东西！

范例三：将 cp 范例中所创建的 /tmp/etc/ 这个目录删除掉！
[root@www tmp]# rmdir /tmp/etc
rmdir: etc: Directory not empty  <== 删不掉啊！因为这不是空的目录！
[root@www tmp]# rm -r /tmp/etc
rm: descend into directory `/tmp/etc'? y
....(中间省略)....
# 因为身份是 root ，默认已经加入了 -i 的选项，所以你要一直按 y 才会删除！
# 如果不想要继续按 y ，可以按下『 [ctrl]-c 』来结束 rm 的工作。
# 这是一种保护的动作，如果确定要删除掉此目录而不要询问，可以这样做：
[root@www tmp]# \rm -r /tmp/etc
# 在命令前加上反斜线，可以忽略掉 alias 的指定选项喔！至於 alias 我们在bash再谈！

范例四：删除一个带有 - 开头的文件
[root@www tmp]# touch ./-aaa-  <==touch这个命令可以创建空文件！
[root@www tmp]# ls -l 
-rw-r--r-- 1 root  root      0 Sep 24 15:03 -aaa-  <==文件大小为0，所以是空文件
[root@www tmp]# rm -aaa-
Try `rm --help' for more information.  <== 因为 "-" 是选项嘛！所以系统误判了！
[root@www tmp]# rm ./-aaa-
这是移除的命令(remove)，要注意的是，通常在Linux系统下，为了怕文件被误杀，所以很多 distributions 都已经默认加入 -i 这个选项了！而如果要连目录下的东西都一起杀掉的话， 例如子目录里面还有子目录时，那就要使用 -r 这个选项了！不过，使用『 rm -r 』这个命令之前，请千万注意了，因为该目录或文件『肯定』会被 root 杀掉！因为系统不会再次询问你是否要砍掉呦！所以那是个超级严重的命令下达呦！ 得特别注意！不过，如果你确定该目录不要了，那么使用 rm -r 来循环杀掉是不错的方式！

另外，范例四也是很有趣的例子，我们在之前就谈过，档名最好不要使用 "-" 号开头， 因为 "-" 后面接的是选项，因此，单纯的使用『 rm -aaa- 』系统的命令就会误判啦！ 那如果使用后面会谈到的正规表示法时，还是会出问题的！所以，只能用避过首位字节是 "-" 的方法啦！ 就是加上本目录『 ./ 』即可！如果 man rm 的话，其实还有一种方法，那就是『 rm -- -aaa- 』也可以啊！

__mv (移动文件与目录，或更名)__
__[root@www ~]# mv [-fiu] source destination__
__[root@www ~]# mv [options] source1 source2 source3 .... directory__
__选项与参数：__
__-f  ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；__
__-i  ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！__
__-u  ：若目标文件已经存在，且 source 比较新，才会升级 (update)__

范例一：复制一文件，创建一目录，将文件移动到目录中
[root@www ~]# cd /tmp
[root@www tmp]# cp ~/.bashrc bashrc
[root@www tmp]# mkdir mvtest
[root@www tmp]# mv bashrc mvtest
# 将某个文件移动到某个目录去，就是这样做！

范例二：将刚刚的目录名称更名为 mvtest2
[root@www tmp]# mv mvtest mvtest2 <== 这样就更名了！简单～
# 其实在 Linux 底下还有个有趣的命令，名称为 rename ，
# 该命令专职进行多个档名的同时更名，并非针对单一档名变更，与mv不同。请man rename。

范例三：再创建两个文件，再全部移动到 /tmp/mvtest2 当中
[root@www tmp]# cp ~/.bashrc bashrc1
[root@www tmp]# cp ~/.bashrc bashrc2
[root@www tmp]# mv bashrc1 bashrc2 mvtest2
# 注意到这边，如果有多个来源文件或目录，则最后一个目标档一定是『目录！』
# 意思是说，将所有的数据移动到该目录的意思！
这是搬移 (move) 的意思！当你要移动文件或目录的时后，呵呵！这个命令就很重要啦！ 同样的，你也可以使用 -u ( update )来测试新旧文件，看看是否需要搬移罗！ 另外一个用途就是『变更档名！』，我们可以很轻易的使用 mv 来变更一个文件的档名呢！不过，在 Linux 才有的命令当中，有个 rename ， 可以用来更改大量文件的档名，你可以利用 man rename 来查阅一下，也是挺有趣的命令喔！

__取得路径的文件名称与目录名称__
我们前面介绍的完整档名 (包含目录名称与文件名称) 当中提到，完整档名最长可以到达 4096 个字节。 那么你怎么知道那个是档名？那个是目录名？嘿嘿！就是利用斜线 (/) 来分辨啊！ 其实，取得档名或者是目录名称，一般的用途应该是在写程序的时候，用来判断之用的啦～ 所以，这部分的命令可以用在第三篇内的 shell scripts 里头喔！ 底下我们简单的以几个范例来谈一谈 basename 与 dirname 的用途！

[root@www ~]# __basename /etc/sysconfig/network__
network         <== 很简单！就取得最后的档名～
[root@www ~]# __dirname /etc/sysconfig/network__
/etc/sysconfig  <== 取得的变成目录名了！
