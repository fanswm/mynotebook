Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2017-12-11T16:38:17+08:00

====== 3 文件内容查阅 ======
Created Monday 11 December 2017

文件内容查阅：
如果我们要查阅一个文件的内容时，该如何是好呢？这里有相当多有趣的命令可以来分享一下： 最常使用的显示文件内容的命令可以说是 cat 与 more 及 less 了！此外，如果我们要查看一个很大型的文件 (好几百MB时)，但是我们只需要后端的几行字而已，那么该如何是好？呵呵！用 tail 呀，此外， tac 这个命令也可以达到！好了，说说各个命令的用途吧！

__cat  由第一行开始显示文件内容__
__tac  从最后一行开始显示，可以看出 tac 是 cat 的倒著写！__
__nl   显示的时候，顺道输出行号！__
__more 一页一页的显示文件内容__
__less 与 more 类似，但是比 more 更好的是，他可以往前翻页！__
__head 只看头几行__
__tail 只看尾巴几行__
__od   以二进位的方式读取文件内容！__
直接检视文件内容
直接查阅一个文件的内容可以使用 cat/tac/nl 这几个命令啊！


__cat (concatenate)__
__[root@www ~]# cat [-AbEnTv]__
__选项与参数：__
__-A  ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；__
__-b  ：列出行号，仅针对非空白行做行号显示，空白行不标行号！__
__-E  ：将结尾的断行字节 $ 显示出来；__
__-n  ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；__
__-T  ：将 [tab] 按键以 ^I 显示出来；__
__-v  ：列出一些看不出来的特殊字符__

范例一：检阅 /etc/issue 这个文件的内容
[root@www ~]# cat /etc/issue
CentOS release 5.3 (Final)
Kernel \r on an \m

范例二：承上题，如果还要加印行号呢？
[root@www ~]# cat -n /etc/issue
     1  CentOS release 5.3 (Final)
     2  Kernel \r on an \m
     3
# 看到了吧！可以印出行号呢！这对於大文件要找某个特定的行时，有点用处！
# 如果不想要编排空白行的行号，可以使用『cat -b /etc/issue』，自己测试看看：

范例三：将 /etc/xinetd.conf 的内容完整的显示出来(包含特殊字节)
[root@www ~]# cat -A /etc/xinetd.conf
#$
....(中间省略)....
$
defaults$
{$
# The next two items are intended to be a quick access place to$
....(中间省略)....
^Ilog_type^I= SYSLOG daemon info $
^Ilog_on_failure^I= HOST$
^Ilog_on_success^I= PID HOST DURATION EXIT$
....(中间省略)....
includedir /etc/xinetd.d$
 $
# 上面的结果限於篇幅，鸟哥删除掉很多数据了。另外，输出的结果并不会有特殊字体，
# 鸟哥上面的特殊字体是要让您发现差异点在哪里就是了。基本上，在一般的环境中，
# 使用 [tab] 与空白键的效果差不多，都是一堆空白啊！我们无法知道两者的差别。
# 此时使用 cat -A 就能够发现那些空白的地方是啥鬼东西了！[tab]会以 ^I 表示，
# 断行字节则是以 $ 表示，所以你可以发现每一行后面都是 $ 啊！不过断行字节
# 在Windows/Linux则不太相同，Windows的断行字节是 ^M$ 罗。
# 这部分我们会在第十章 vim 软件的介绍时，再次的说明到喔！
嘿嘿！Linux 里面有『猫』命令？喔！不是的， cat 是 Concatenate （连续）的简写， 主要的功能是将一个文件的内容连续的印出在萤幕上面！例如上面的例子中，我们将 /etc/issue 印出来！如果加上 -n 或 -b 的话，则每一行前面还会加上行号呦！

鸟哥个人是比较少用 cat 啦！毕竟当你的文件内容的行数超过 40 行以上，嘿嘿！根本来不及在萤幕上看到结果！ 所以，配合等一下要介绍的 more 或者是 less 来运行比较好！此外，如果是一般的 DOS 文件时，就需要特别留意一些奇奇怪怪的符号了， 例如断行与 [tab] 等，要显示出来，就得加入 -A 之类的选项了！


tac (反向列示)
[root@www ~]# tac /etc/issue

Kernel \r on an \m
CentOS release 5.3 (Final)
# 嘿嘿！与刚刚上面的范例一比较，是由最后一行先显示喔！
tac 这个好玩了！怎么说呢？详细的看一下， cat 与 tac ，有没有发现呀！对啦！ tac 刚好是将 cat 反写过来，所以他的功能就跟 cat 相反啦， cat 是由『第一行到最后一行连续显示在萤幕上』，而 tac 则是『 由最后一行到第一行反向在萤幕上显示出来 』，很好玩吧！


__nl (添加行号列印)__
__[root@www ~]# nl [-bnw] 文件__
__选项与参数：__
__-b  ：指定行号指定的方式，主要有两种：__
__      -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；__
__      -b t ：如果有空行，空的那一行不要列出行号(默认值)；__
__-n  ：列出行号表示的方法，主要有三种：__
__      -n ln ：行号在萤幕的最左方显示；__
__      -n rn ：行号在自己栏位的最右方显示，且不加 0 ；__
__      -n rz ：行号在自己栏位的最右方显示，且加 0 ；__
__-w  ：行号栏位的占用的位数。__

范例一：用 nl 列出 /etc/issue 的内容
[root@www ~]# nl /etc/issue
     1  CentOS release 5.3 (Final)
     2  Kernel \r on an \m

# 注意看，这个文件其实有三行，第三行为空白(没有任何字节)，
# 因为他是空白行，所以 nl 不会加上行号喔！如果确定要加上行号，可以这样做：

[root@www ~]# nl -b a /etc/issue
     1  CentOS release 5.3 (Final)
     2  Kernel \r on an \m
     3
# 呵呵！行号加上来罗～那么如果要让行号前面自动补上 0 呢？可这样

[root@www ~]# nl -b a -n rz /etc/issue
000001  CentOS release 5.3 (Final)
000002  Kernel \r on an \m
000003
# 嘿嘿！自动在自己栏位的地方补上 0 了～默认栏位是六位数，如果想要改成 3 位数？

[root@www ~]# nl -b a -n rz -w 3 /etc/issue
001     CentOS release 5.3 (Final)
002     Kernel \r on an \m
003
# 变成仅有 3 位数罗～
nl 可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能呢。

可翻页检视
前面提到的 nl 与 cat, tac 等等，都是一次性的将数据一口气显示到萤幕上面，那有没有可以进行一页一页翻动的命令啊？ 让我们可以一页一页的观察，才不会前面的数据看不到啊～呵呵！有的！那就是 more 与 less 罗～


more (一页一页翻动)
[root@www ~]# more /etc/man.config
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
....(中间省略)....
--More--(28%)  <== 重点在这一行喔！你的光标也会在这里等待你的命令
仔细的给他看到上面的范例，如果 more 后面接的文件内容行数大於萤幕输出的行数时， 就会出现类似上面的图示。重点在最后一行，最后一行会显示出目前显示的百分比， 而且还可以在最后一行输入一些有用的命令喔！在 more 这个程序的运行过程中，你有几个按键可以按的：

__空白键 (space)：代表向下翻一页；__
__Enter         ：代表向下翻『一行』；__
__/字串         ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；__
__:f            ：立刻显示出档名以及目前显示的行数；__
__q             ：代表立刻离开 more ，不再显示该文件内容。__
__b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。__
要离开 more 这个命令的显示工作，可以按下 q 就能够离开了。而要向下翻页，就使用空白键即可。 比较有用的是搜寻字串的功能，举例来说，我们使用『 more /etc/man.config 』来观察该文件， 若想要在该文件内搜寻 MANPATH 这个字串时，可以这样做：

[root@www ~]# more /etc/man.config
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
....(中间省略)....
/MANPATH   <== 输入了 / 之后，光标就会自动跑到最底下一行等待输入！
如同上面的说明，输入了 / 之后，光标就会跑到最底下一行，并且等待你的输入， 你输入了字串并按下[enter]之后，嘿嘿！ more 就会开始向下搜寻该字串罗～而重复搜寻同一个字串， 可以直接按下 n 即可啊！最后，不想要看了，就按下 q 即可离开 more 啦！


__less (一页一页翻动)__
[root@www ~]# less /etc/man.config
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
....(中间省略)....
:   <== 这里可以等待你输入命令！
less 的用法比起 more 又更加的有弹性，怎么说呢？在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，呵呵！就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，你瞧，是不是更容易使用来观看一个文件的内容了呢！

除此之外，在 less 里头可以拥有更多的『搜寻』功能喔！不止可以向下搜寻，也可以向上搜寻～ 实在是很不错用～基本上，可以输入的命令有：

__空白键    ：向下翻动一页；__
__[pagedown]：向下翻动一页；__
__[pageup]  ：向上翻动一页；__
__/字串     ：向下搜寻『字串』的功能；__
__?字串     ：向上搜寻『字串』的功能；__
__n         ：重复前一个搜寻 (与 / 或 ? 有关！)__
__N         ：反向的重复前一个搜寻 (与 / 或 ? 有关！)__
__q         ：离开 less 这个程序；__
查阅文件内容还可以进行搜寻的动作～瞧～ less 是否很不错用啊！ 其实 less 还有很多的功能喔！详细的使用方式请使用 man less 查询一下啊！ ^_^

你是否会觉得 less 使用的画面与环境与 man page 非常的类似呢？没错啦！因为man这个命令就是呼叫 less 来显示说明文件的内容的！ 现在你是否觉得 less 很重要呢？ ^_^

数据撷取
我们可以将输出的数据作一个最简单的撷取，那就是取出前面 (head) 与取出后面 (tail) 文字的功能。 不过，要注意的是， head 与 tail 都是以『行』为单位来进行数据撷取的喔！


__head (取出前面几行)__
__[root@www ~]# head [-n number] 文件 __
__选项与参数：__
__-n  ：后面接数字，代表显示几行的意思__

[root@www ~]# head /etc/man.config
# 默认的情况中，显示前面十行！若要显示前 20 行，就得要这样：
[root@www ~]# head -n 20 /etc/man.config

范例：如果后面100行的数据都不列印，只列印/etc/man.config的前面几行，该如何是好？
[root@www ~]# head -n -100 /etc/man.config
head 的英文意思就是『头』啦，那么这个东西的用法自然就是显示出一个文件的前几行罗！ 没错！就是这样！若没有加上 -n 这个选项时，默认只显示十行，若只要一行呢？那就加入『 head -n 1 filename 』即可！

另外那个 -n 选项后面的参数较有趣，如果接的是负数，例如上面范例的-n -100时，代表列前的所有行数， 但不包括后面100行。举例来说，/etc/man.config共有141行，则上述的命令『head -n -100 /etc/man.config』 就会列出前面41行，后面100行不会列印出来了。这样说，比较容易懂了吧？ ^_^


__tail (取出后面几行)__
__[root@www ~]# tail [-n number] 文件 __
__选项与参数：__
__-n  ：后面接数字，代表显示几行的意思__
__-f  ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测__

[root@www ~]# tail /etc/man.config
# 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：
[root@www ~]# tail -n 20 /etc/man.config

范例一：如果不知道/etc/man.config有几行，却只想列出100行以后的数据时？
[root@www ~]# tail -n +100 /etc/man.config

范例二：持续侦测/var/log/messages的内容
[root@www ~]# tail -f /var/log/messages
  <==要等到输入[crtl]-c之后才会离开tail这个命令的侦测！
有 head 自然就有 tail ( 尾巴 ) 罗！没错！这个 tail 的用法跟 head 的用法差不多类似，只是显示的是后面几行就是了！默认也是显示十行，若要显示非十行，就加 -n number 的选项即可。

范例一的内容就有趣啦！其实与head -n -xx有异曲同工之妙。当下达『tail -n +100 /etc/man.config』 代表该文件从100行以后都会被列出来，同样的，在man.config共有141行，因此第100~141行就会被列出来啦！ 前面的99行都不会被显示出来喔！

至於范例二中，由於/var/log/messages随时会有数据写入，你想要让该文件有数据写入时就立刻显示到萤幕上， 就利用 -f 这个选项，他可以一直侦测/var/log/messages这个文件，新加入的数据都会被显示到萤幕上。 直到你按下[crtl]-c才会离开tail的侦测喔！

例题：
假如我想要显示 /etc/man.config 的第 11 到第 20 行呢？
答：
这个应该不算难，想一想，在第 11 到第 20 行，那么我取前 20 行，再取后十行，所以结果就是：『 head -n 20 /etc/man.config | tail -n 10 』，这样就可以得到第 11 到第 20 行之间的内容了！ 但是里面涉及到管线命令，需要在第三篇的时候才讲的到！

__非纯文字档： od__
我们上面提到的，都是在查阅纯文字档的内容。 那么万一我们想要查阅非文字档，举例来说，例如 /usr/bin/passwd 这个运行档的内容时， 又该如何去读出资讯呢？事实上，由於运行档通常是 binary file ，使用上头提到的命令来读取他的内容时， 确实会产生类似乱码的数据啊！那怎么办？没关系，我们可以利用 od 这个命令来读取喔！

__[root@www ~]# od [-t TYPE] 文件__
__选项或参数：__
__-t  ：后面可以接各种『类型 (TYPE)』的输出，例如：__
__      a       ：利用默认的字节来输出；__
__      c       ：使用 ASCII 字节来输出__
__      d[size] ：利用十进位(decimal)来输出数据，每个整数占用 size bytes ；__
__      f[size] ：利用浮点数值(floating)来输出数据，每个数占用 size bytes ；__
__      o[size] ：利用八进位(octal)来输出数据，每个整数占用 size bytes ；__
__      x[size] ：利用十六进位(hexadecimal)来输出数据，每个整数占用 size bytes ；__

范例一：__请将/usr/bin/passwd的内容使用ASCII方式来展现！__
__[root@www ~]# od -t c /usr/bin/passwd__
0000000 177   E   L   F 001 001 001  \0  \0  \0  \0  \0  \0  \0  \0  \0
0000020 002  \0 003  \0 001  \0  \0  \0 260 225 004  \b   4  \0  \0  \0
0000040 020   E  \0  \0  \0  \0  \0  \0   4  \0      \0  \a  \0   (  \0
0000060 035  \0 034  \0 006  \0  \0  \0   4  \0  \0  \0   4 200 004  \b
0000100   4 200 004  \b 340  \0  \0  \0 340  \0  \0  \0 005  \0  \0  \0
.....(后面省略)....
# 最左边第一栏是以 8 进位来表示bytes数。以上面范例来说，第二栏0000020代表开头是
# 第 16 个 byes (2x8) 的内容之意。

范例二：__请将/etc/issue这个文件的内容以8进位列出储存值与ASCII的对照表__
__[root@www ~]# od -t oCc /etc/issue__
0000000 103 145 156 164 117 123 040 162 145 154 145 141 163 145 040 065
          C   e   n   t   O   S       r   e   l   e   a   s   e       5
0000020 056 062 040 050 106 151 156 141 154 051 012 113 145 162 156 145
          .   2       (   F   i   n   a   l   )  \n   K   e   r   n   e
0000040 154 040 134 162 040 157 156 040 141 156 040 134 155 012 012
          l       \   r       o   n       a   n       \   m  \n  \n
0000057
# 如上所示，可以发现每个字节可以对应到的数值为何！
# 例如e对应的记录数值为145，转成十进位：1x8^2+4x8+5=101。
利用这个命令，可以将 data file 或者是 binary file 的内容数据给他读出来喔！ 虽然读出的来数值默认是使用非文字档，亦即是 16 进位的数值来显示的， 不过，我们还是可以透过 -t c 的选项与参数来将数据内的字节以 ASCII 类型的字节来显示， 虽然对於一般使用者来说，这个命令的用处可能不大，但是对於工程师来说， 这个命令可以将 binary file 的内容作一个大致的输出，他们可以看得出东西的啦～ ^_^

如果对纯文字档使用这个命令，你甚至可以发现到 ASCII 与字节的对照表！非常有趣！ 例如上述的范例二，你可以发现到每个英文字 e 对照到的数字都是 145，转成十进位你就能够发现那是 101 罗！ 如果你有任何程序语言的书，拿出来对照一下 ASCII 的对照表，就能够发现真是正确啊！呵呵！

__修改文件时间或建置新档： touch__
我们在 ls 这个命令的介绍时，有稍微提到每个文件在linux底下都会记录许多的时间参数， 其实是有三个主要的变动时间，那么三个时间的意义是什么呢？

__modification time (mtime)：__
__当该文件的『内容数据』变更时，就会升级这个时间！__内容数据指的是文件的内容，而不是文件的属性或权限喔！

__status time (ctime)：__
当该文件的『状态 (status)』改变时，就会升级这个时间，举例来说，像是__权限与属性被更改了__，都会升级这个时间啊。 

__access time (atime)：__
当『该文件的内容被取用』时，就会升级这个读取时间 (access)。举例来说，我们使用 cat 去读取 /etc/man.config ， 就会升级该文件的 atime 了。
这是个挺有趣的现象，举例来说，我们来看一看你自己的 /etc/man.config 这个文件的时间吧！

[root@www ~]# ls -l /etc/man.config
-rw-r--r-- 1 root root 4617 Jan  6  2007 /etc/man.config
[root@www ~]# ls -l --time=atime /etc/man.config
-rw-r--r-- 1 root root 4617 Sep 25 17:54 /etc/man.config
[root@www ~]# ls -l --time=ctime /etc/man.config
-rw-r--r-- 1 root root 4617 Sep  4 18:03 /etc/man.config
看到了吗？在默认的情况下，ls 显示出来的是该文件的 mtime ，也就是这个文件的内容上次被更动的时间。 至於鸟哥的系统是在 9 月 4 号的时候安装的，因此，这个文件被产生导致状态被更动的时间就回溯到那个时间点了(ctime)！ 而还记得刚刚我们使用的范例当中，有使用到man.config这个文件啊，所以啊，他的 atime 就会变成刚刚使用的时间了！

文件的时间是很重要的，因为，如果文件的时间误判的话，可能会造成某些程序无法顺利的运行。 OK！那么万一我发现了一个文件来自未来，该如何让该文件的时间变成『现在』的时刻呢？ 很简单啊！就用『touch』这个命令即可！

Tips:
嘿嘿！不要怀疑系统时间会『来自未来』喔！很多时候会有这个问题的！举例来说在安装过后系统时间可能会被改变！ 因为台湾时区在国际标准时间『格林威治时间, GMT』的右边，所以会比较早看到阳光，也就是说，台湾时间比GMT时间快了八小时！ 如果安装行为不当，我们的系统可能会有八小时快转，你的文件就有可能来自八小时后了。

至於某些情况下，由於BIOS的配置错误，导致系统时间跑到未来时间，并且你又创建了某些文件。 等你将时间改回正确的时间时，该文件不就变成来自未来了？^_^	鸟哥的图示
__[root@www ~]# touch [-acdmt] 文件__
__选项与参数：__
__-a  ：仅修订 access time；__
__-c  ：仅修改文件的时间，若该文件不存在则不创建新文件；__
__-d  ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date="日期或时间"__
__-m  ：仅修改 mtime ；__
__-t  ：后面可以接欲修订的时间而不用目前的时间，格式为[YYMMDDhhmm]__

范例一：新建一个空的文件并观察时间
[root@www ~]# cd /tmp
[root@www tmp]# touch testtouch
__[root@www tmp]# ls -l testtouch__
-rw-r--r-- 1 root root 0 Sep 25 21:09 testtouch
# 注意到，这个文件的大小是 0 呢！在默认的状态下，如果 touch 后面有接文件，
# 则该文件的三个时间 (atime/ctime/mtime) 都会升级为目前的时间。若该文件不存在，
# 则会主动的创建一个新的空的文件喔！例如上面这个例子！

范例二：将 ~/.bashrc 复制成为 bashrc，假设复制完全的属性，检查其日期
[root@www tmp]# cp -a ~/.bashrc bashrc
[root@www tmp]# __ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc__
-rw-r--r-- 1 root root 176 Jan  6  2007 bashrc  <==这是 mtime
-rw-r--r-- 1 root root 176 Sep 25 21:11 bashrc  <==这是 atime
-rw-r--r-- 1 root root 176 Sep 25 21:12 bashrc  <==这是 ctime
在上面这个案例当中我们使用了『ll』这个命令(两个英文L的小写)，这个命令其实就是『ls -l』的意思， ll本身不存在，是被『做出来』的一个命令别名。相关的命令别名我们会在bash章节当中详谈的，这里先知道ll="ls -l"即可。 __至於分号『 ; 』则代表连续命令的下达啦__！你可以在一行命令当中写入多重命令， 这些命令可以『依序』运行。由上面的命令我们会知道ll那一行有三个命令被下达在同一行中。

至於运行的结果当中，我们可以发现数据的内容与属性是被复制过来的，因此文件内容时间(mtime)与原本文件相同。 但是由於这个文件是刚刚被创建的，因此状态(ctime)与读取时间就便呈现在的时间啦！ 那如果你想要变更这个文件的时间呢？可以这样做：

范例三：__修改案例二的 bashrc 文件，将日期调整为两天前__
__[root@www tmp]# touch -d "2 days ago" bashrc__
[root@www tmp]# ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc
-rw-r--r-- 1 root root 176 Sep 23 21:23 bashrc
-rw-r--r-- 1 root root 176 Sep 23 21:23 bashrc
-rw-r--r-- 1 root root 176 Sep 25 21:23 bashrc
# 跟上个范例比较看看，本来是 25 日的变成了 23 日了 (atime/mtime)～
# 不过， ctime 并没有跟著改变喔！

范例四：将上个范例的 bashrc 日期改为 2007/09/15 2:02
[root@www tmp]# touch -t 0709150202 bashrc
[root@www tmp]# ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc
-rw-r--r-- 1 root root 176 Sep 15  2007 bashrc
-rw-r--r-- 1 root root 176 Sep 15  2007 bashrc
-rw-r--r-- 1 root root 176 Sep 25 21:25 bashrc
# 注意看看，日期在 atime 与 mtime 都改变了，但是 ctime 则是记录目前的时间！
透过 touch 这个命令，我们可以轻易的修订文件的日期与时间。并且也可以创建一个空的文件喔！ 不过，要注意的是，即使我们复制一个文件时，复制所有的属性，但也没有办法复制 ctime 这个属性的。 ctime 可以记录这个文件最近的状态 (status) 被改变的时间。无论如何，还是要告知大家， 我们平时看的文件属性中，比较重要的还是属於那个 mtime 啊！我们关心的常常是这个文件的『内容』 是什么时候被更动的说～了乎？

无论如何， __touch 这个命令最常被使用的情况是：__

__创建一个空的文件；__
__将某个文件日期修订为目前 (mtime 与 atime)__
