Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-04-30T15:48:33+08:00

====== Linux 系统和 Shell 编程问题录简解 by 001 ======
创建日期 星期二 30 四月 2019

https://zhuanlan.zhihu.com/p/62543626?utm_source=com.youdao.note&utm_medium=social&utm_oi=33829276352512
Linux 系统和 Shell 编程问题题录及其简解由生物信息学开源社区 openbiox 的 playcloud 团队贡献。

本文内容主要贡献团队成员（001）主要包括 Yang Yang, Liao Kai, Wang Yiguan, Zhang Ziying, Jianfeng Li。本文所涉及的题录已单独进行发布：这里。

简答题
1. 计算机硬件和软件的关系是什么？
硬件是计算机系统的物理组成部分，即计算机系统中的各种物理装置，包括控制器、运算器、内存储器、I/O设备（如硬盘、键盘）以及外存储器等。它是计算机系统的物质基础。

软件系统就是所有程序、数据和相关文件的集合。从狭义的角度上讲，软件是指计算机运行所需的各种程序。没有硬件，谈不上应用计算机。但是，光有硬件而没有软件，计算机也不能工作。（1）硬件和软件互相依存；（2）硬件和软件无严格界线；（3）硬件和软件协同发展。

计算机软件和硬件密不可分，协调工作。软件的运行通过硬件呈现给用户，用户通过硬件进行开发及修改软件，二者相互依存，缺一不可。离开了硬件的软件什么也做不了，离开软件的硬件也只是摆设。对于计算机而言，软件像是灵魂，硬件像是肉体。二者相互依存。同时二者也相互制约。在计算机的早期，硬件很薄弱，限制了计算机的发展；如今，硬件配置很多都很高了，软件的优化对提高计算机的性能十分关键。以手机为例，早期的智能机内存通常只有512MB，提高手机内存是解决手机卡顿的关键因素，而如今，很多手机的内存已达10GB甚至12GB，超过了很多电脑的内存，但是很多时候仍然卡顿，一个重要的原因是软件优化不够好（很多程序设计者在面对大内存时，以不将内存优化作为程序设计的重点，于是出现了你有多少硬件资源，我软件就要占用多少硬件资源），占用了大量的硬件资源。

综上，硬件和软件是计算机重要组成部分，缺一不可。计算机性能的提升即依赖于硬件配置的提高，也依赖于软件水平的优化。

参考资料：

https://www.sophia.org/tutorials/the-relationship-between-hardware-and-software
https://www.quora.com/What-is-the-relation-between-hardware-and-software-2
2. 常见的 Linux 发行版本有哪些？它们的主要差别在什么地方？
Linux 发行版本是基于Linux内核和软件包管理系统创建的操作系统。通常一个 Linux 发行版包括 Linux 内核、GNU 工具和库、其他一些软件以及窗口系统、窗口管理器和桌面环境。 迄今为止，已经有超过 600 多个 Linux 发行版本，其中将近 500 个仍处于活跃开发状态。其中最常用的一些商业支持发行版有：Fedora(Red Hat), openSUSE(SUSE) 和 Ubuntu，社区驱动的发行版有：Debian, Slackware, Gentoo和 Arch Linux。 值得一提的是 Android 系统，我们知道 Android 也是基于 Linux 的，但是它算不算一个 Linux 发行版本呢？很多大佬有不同的意见，有人认为 Android 也是一种发行版，有人指出 Android 缺少包括 glibc 在内的很多 GUN 工具，因而不能算是一种 Linux 发行版。

Linux 发行版 = Linux 内核 + 商业软件

常见的 Linux 发行版：

国外：RedHat、Fedora、Centos、SUSE、Debian、Ubuntu、Mint、Arch、Manjaro
国内：红旗、Deepin
是不是一千个用户就有一千个 Linux 系统推荐理由？

用户一：

Ubuntu 对计算机硬件的支持好于 Centos 和 Debian，兼容性强，适合新手（例如本人）；CentOS 去除很多与服务器功能无关的应用，系统简单但非常稳定，命令行操作可以方便管理系统和应用,常见于公司系统；Debian 整个系统基础核心非常小，不仅稳定，而且占用硬盘空间小，占用内存小，对于小内存，首选 Debian，对于非常熟悉 Linux 系统的 vps 高手，首选 Debian。

用户二：

Centos 系统有非常多的商业公司部署在生产环境上的服务器都是使用 CentOS 系统，Centos 是从 Redhat 源代码编译重新发布版，Centos 去除很多与服务器功能无关的应用，系统简单但非常稳定，命令行操作可以方便管理系统和应用，并且有帮助文档和社区的支持。
Ubuntu系统有着靓丽的用户界面，完善的包管理系统，强大的软件源支持，丰富的技术社区，并且 Ubuntu 对计算机硬件的支持优于 Centos 和 Debian，兼容性强，Ubuntu 应用非常多，但是对于服务器操作系统来说，并不需要太多的应用程序，需要的是稳定，操作方便，维护简单的系统。如果你需要在服务器端使用图形界面，Ubuntu 是一个不错的选择，你需要注意的是，图形界面占用的内存非常大，而内存越大的 vps 价格也越高；
Debian 系统也非常适合做服务器操作系统，与 Ubuntu 比较，它没有太多的花哨，稳定压倒一切，对于服务器操作系统来说是一条不变的真理，Debian 这 个Linux 系统，底层非常稳定，内核和内存的占用都非常小，在小内存的 vps 就可以顺畅运行 Debian,比如 128M 的内存，但 Debian 的帮助文档和技术资料比较少，对于小内存，首选 Debian，对于非常熟悉 Linux 系统的 vps 高手，首选 Debian。
用户三：

常见的发行版本如下：

基于RPM：主要是Red Hat和SUSE使用.rpm文件格式作为包文件，包括Red Hat Linux, CentOS, Fedora, openSUSE等。
基于Debian：使用.deb文件格式作为包文件，包括Kali Linux, Ubuntu
基于Pacman：能够有效解决各个软件包之间的依赖关系，自动下载安装相关的包，包括Arch Linux，Manjaro Linux等。
基于Gentoo：如Chrome OS等。
参考资料：

https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg
https://en.wikipedia.org/wiki/Linux_distribution
https://www.techradar.com/news/best-linux-distro
https://www.lifewire.com/top-linux-distributions-of-all-time-4084559
https://itsfoss.com/best-linux-beginners/
https://www.howtogeek.com/191207/10-of-the-most-popular-linux-distributions-compared/
3. 如何在一台全新的计算机上安装 Linux 操作系统？
Windows 是最受欢迎的桌面操作系统之一，因为到现在为止，大多数办公和娱乐软件应用（如游戏）对 Linux 系统的支持很不够。尽管国内的 Deeplin 团队已经移植了很多 Windows 下的常用工具（如搜狗输入法，QQ、网易云音乐等），对于 Linux 新手来说，想完全不使用 Windows 系统仍然有相当大的难度。特别当某些软件只能在 Windows 上运行，而又需要多人协作时。所以，一般我们会推荐绝大多数普通 Windows 用户通过安装 Linux 虚拟机或者双系统来入门 Linux，如果是依赖 Linux 环境的日常开发，也可以使用 Windows 子系统（Windows Subsystem，WSL）进行。

安装 Linux 系统有不同的方法，但通常最常用的是下载并刻录 Live CD 的方式。首先需要下载安装文件，待 .iso 文件下载完成后，放入空白 CD，把 ISO 文件刻录上去。CD 刻录完成后，重新启动计算机，等待屏幕显示“按任意键从CD启动”（“press any key to boot from CD”）的提示，通过光盘引导，进入 Linux 安装程序；与 Live CD 相比，Live USB 需要一些额外设置。插上制作好的 Live USB，重启计算机并进入 BIOS 设置（通常是启动时，按 Delete 键进入，启动画面上会提示）。进入 BIOS 引导单元（Boot），然后找到更改系统引导顺序的选项，把 USB 驱动器调整到列表顶部，最后保存设置并退出 BIOS。再次重启计算机，系统就会自动进入 Unetbootin 菜单，这时你就可以进行 Linux 的安装了。

以上简单概括就是和安装 Windows 系统相似，下载系统镜像文件 - 刻录系统盘 - BIOS刻录盘启动安装即可。

需要注意的是，在尝试安装 Linux系统之前，你可能需要先了解 Linux 的文件系统，以及挂载相关的概念。另外，不同发布版本的 Linux 系统安装难易是有差别，建议尝试不同发布版本 Linux 并选择最适合你的一款。

参考资料：

https://blog.csdn.net/tototuzuoquan/article/details/41368607
https://mp.weixin.qq.com/s/pom-xQzlGy8enX9Io1FLaQ
https://www.cnet.com/how-to/how-to-install-linux/
https://www.zdnet.com/article/how-to-install-linux-mint-on-your-windows-pc/
https://www.zdnet.com/article/installing-linux-on-your-pc-is-super-easy-heres-how-to-do-it/
4. 在 Win10 自带的子系统下运行 Ubuntu，和独立使用 Ubuntu 系统，前者的优缺点如何？
优点：

不必单独安装 Ubuntu 操作系统，大部分情况下使用 Windows 系统，可视化好，处理数据时使用 Ubuntu。
可以在 Windows 上使用 Linux。 命令，这对于广大习惯于Linux系统的程序员来说带来了极大的方便。在一定程度上避免了使用虚拟机和双系统的麻烦。
安装简便。在Windows上你只需要点几次鼠标，激活WSL功能，然后去微软商店免费下载即可。同时也是免费的。
可以针对Windows系统操作。可以访问、检索、编辑、处理Windows系统的文件。
缺点：

功能有限，WSL 无法运行所有Linux软件（如32位二进制文件）或需要在WSL中未实现的特定Linux内核服务的软件。如果你需要完整的Linux服务，或者有某些特别的需求，WSL并不一定能够满足你，这个时候虚拟机或者是一个更好的选择。
图形化界面主要依靠本地 X server 或者远程桌面实现，可能无法使用部分基于 Linux 的图形界面程序。
由于WSL中没有“真正的”Linux内核，因此对于一些设备驱动程序支持还很不好，如 Nvida 显卡。
尽管 WSL 的 CPU 和内存使用性能与正常安装的 Linux 系统接近，但是由于 Windows 文件系统的拖累以及 Windows 安全扫描工具的存在，WSL 系统的硬盘读写速度较原生的 Linux 系统仍有较大差距。
微软似乎正在变成开源的拥簇，不光在 Windows 上开放了 WSL，还收购了 GitHub。虽然说 WSL 还存在一定的局限性，但是它的逐渐变好，越来越完善。

参考资料：

https://virtualizationreview.com/articles/2018/07/17/reasons-to-not-use-wsl.aspx
https://www.quora.com/Why-has-Microsoft-created-WSL-What-are-its-advantages-over-earlier-methods-of-using-Linux-in-Windows
https://devblogs.microsoft.com/premier-developer/why-developers-should-install-wsl-today/
https://www.reddit.com/r/elementaryos/comments/67orea/advantages_disadvantages_over_windows_10/
http://www.akitaonrails.com/2017/09/20/windows-subsystem-for-linux-is-good-but-not-enough-yet
5. Linux 系统常见的文件系统有哪几种？Windows系统上看到的C盘、D盘，在Linux 系统下是以什么样的形式存在？
在计算机中，文件系统（file system）是命名文件及放置文件的逻辑存储和恢复的系统。文件系统指定命名文件的规则。这些规则包括文件名的字符数最大量，哪种字符可以使用，以及某些系统中文件名后缀可以有多长。文件系统还包括通过目录结构找到文件的指定路径的格式。

Linux 下没有 C、D 盘等硬盘分区的概念。Linux 下是采用目录形式来代替 Windows 中硬盘分区的概念，即我们常说的 Linux 系统中，“一切皆是文件”。即便是传统意义上的文件夹，在 Linux 系统中也是文件。程序、服务、文本、图片等等也都是文件，一些外接设备也是文件。主要支持的文件系统包括 ext2、ext3、vfat、ntfs、iso9660、jffs、romfs，nfs 以及其他更新的文件系统，比如华为的 erofs 文件系统等。

（1）ext 专门为 Linux 设计的，为 Linux 核心所做的第一个文件系统。单个文件最大限制：未知；该文件系统最大支持 2 GB的容量。

（2）ext2 由 Rémy Card 设计，用以代替 ext，是LINUX内核所用的文件系统。单个文件最大限制 2 TB；该文件系统最大支持 32 TB 的容量。

（3）ext3一个日志文件系统。单个文件最大限制 16 TB，该文件系统最大支持 32 TB的容量。

（4）ext4Theodore Tso 领导的开发团队实现,Linux 系统下的日志文件系统。单个文件最大限制 16 TB，该文件系统最大支持 1EB 的容量。

（5）JFS2 一种字节级日志文件系统,该文件系统主要是为满足服务器的高吞吐量和可靠性需求而设计、开发的。单个文件最大限制 16 TB，该文件系统最大支持 1 PB的容量。

目前绝大多数 Linux 发行版都是默认 ext4 作为默认文件系统，在这之前还有 ext3、ext2、ext等。 在 ext 文件系统使用之前，Unix 主要使用 MINIX 文件系统，但是它不是开源免费的。当 Linus Torvalds 开发 Linux 内核时，也是使用的 MINIX 文件系统。不过该系统只能最大支持 14 个字节的文件名和 64 MB 大小的存储空间。 1992 年，Remy Card 发布了第一个 ext 系统，并应用于 Linux。ext 系统可以支持 255 字节文件名和 2 GB 的存储空间。不过 ext 的缺点是一个文件只能有一个时间戳，而不是像今天这样可以有 3 个时间戳（创建时间、访问时间和修改时间）。于是很快 Remy 又发布了 ext2 文件系统，ext2 可以处理数 GB 大小的文件和数 TB 大小的存储空间。但是它的问题是如果系统出现问题或者向硬盘写入数据时断电，会造成整个灾难性的崩溃，其他很多文件也会受到牵连。而且文件的碎片化问题严重拖慢了系统速度。在 1993 年，Stephen Tweedie 发布了 ext3 文件系统，它和微软的 NTFS 文件系统相似，采用了日志化 journal 的方法来处理断电问题，日志是磁盘上的一块专门的分区，来记录磁盘读写情况。一次写入完成之后，会记录在日志中，如果在写的过程中出现来断电等情况而中断，那么重新启动系统后，通过日志能够识别出之前不完整的写入，并将该写入删除。这就意味着采用 ext3 系统可以很好的保护其他文件不受断电等因素影响。ext3 采用 32 位地址，这就意味着它能处理的文件最大 2 TB，文件系统最大到 16 TB。在 2006 年，出现了 ext4 文件系统，与 ext3 文件系统相比，ext4 的优势在于：

向后兼容，能够兼容ext3文件系统。
更大的文件系统，ext4采用48位地址，可以最大支持16TB文件和1EB（1000000TB）大小的文件系统。
更快的读写速度。
减少磁盘碎片的产生。
ext3最大支持32000个子目录，而ext4则没有任何限制。
对文件日志的检查，确保稳定性。
更精细的时间戳。ext3可以精确到秒，而ext4可以精确到纳秒级，同时ext4扩展了可以记录的时间尺度到AD2446年。
补充知识点：

Windows 中的 C 盘、D 盘是以 “" 为路径，而 Linux 以 “/”为路径。

Windows 常见的文件系统：NTFS：全名 New Technology File System 即新技术文件系统，被普遍用于 Windows XP 以上版本的 Windows 中，取代原来 FAT32。（1）应用范围：NTFS 多用于台式机电脑、笔记本及平板电脑、移动硬盘等大中型空间容量的磁盘。而 FAT32 多用于 U 盘、内存卡等小型空间容量的磁盘。它们采用 FAT32 的原因是，NTFS 主要是针对传统机械硬盘而设计的，对于U盘或内存卡这种闪存材料不适用。NTFS 分区采用“日志式”的文件系统，这种格式会对 U 盘这种闪存储介质会造成较大的负担，会直接造成U盘容易损坏；（2）最大分区容量限制：FAT32 在 WIN2000 和 XP 系统中最大分区容量限制为 2 TB的容量。NTFS 没有容量限制，硬盘空间的容量有多大，NTFS 就可以分到多大；（3）单个文件容量限制：FAT32 在实际运行中不支持单个文件大于 4 GB 的文件，一旦超过容量限制那么系统就会提示磁盘空间不足。NTFS 已经突破了单个文件 4 GB 的容量限制，已经差不多完全替代 FAT32 分区格式了，已在 Win7/Win8/Win10 系统中广泛运用。（4）安全：NTFS分区格式，用户可以对该格式分区下所有的文件夹或文件进行加密、修改、写入等权限的安全设置，而 FAT32 没有这种功能。

系统分区：在 Windows 我们经常看到 C 盘或 D 盘等的系统分区。在 Linux 也存在分区，但是和 Windows 上的分区完全不一样。分区的目的主要是为了保护数据和系统的稳定，当一个分区出现问题时，不会影响和破坏其他分区。在Linux系统上有两种主要的分区：

数据分区data partition：存放正常 Linux 系统的数据，包括系统的启动和运行等等。
交换分区swap partition：用来使用一定的硬盘空间来扩展计算机的内存。交换分区只能系统自己有访问权限，通常情况下，你是看不到的。它的存在主要是为了保证系统的稳定。在 Linux 系统中，你很少看到“系统内存不足”的提示，这主要是因为交换分区的存在。虽然访问交换分区比访问物理内存慢，但能够很大程度上解决系统内存的问题。在安装 Linux 系统时，我们通常会把交换分区的大小设为实际物理内存的两倍，即如果你有 512MB 的 RAM，那么交换分区则设为 1GB 大小。
参考资料：

https://opensource.com/article/18/4/ext4-filesystem
https://en.wikipedia.org/wiki/File_system
https://www.tecmint.com/linux-file-system-explained/
https://www.tldp.org/LDP/intro-linux/html/sect_03_01.html
https://www.pks.mpg.de/~mueller/docs/suse10.2/html/opensuse-manual_en/manual/sec.new.fs.html
https://www.howtogeek.com/howto/33552/htg-explains-which-linux-file-system-should-you-choose/
6. 什么是“根目录“、“家目录”？
根目录（/）只有一个，是设备的最顶层目录，几乎所有与 Linux 有关的东西都在根目录 / 下，它是系统结构的最高层级，其他一切目录都在根目录下。。

家（HOME）目录是是每个用户登录系统后所在的目录，是为了多用户使用系统和方便管理而为设置的一个目录，通常在 /home 下，用于存储用户私密文件的子目录。每个用户通常只能访问自己的家目录。一般以用户名作为目录，可以用 cd ~ 快速进入当前用户的家目录。

7. 简述文件的绝对路径和相对路径
文件路径是文件在整个系统中的位置。绝对路径是从系统根目录 / 到该文件的路由过程，即从根目录开始的路径。

相对路径的概念是相对于自己的目标文件位置。如以当前目录（.）为参照物，其他文件的相对路径就是从当前命令行程序所在的工作路径 pwd 到达目标文件的路由过程。.. 表示父目录。

8. Linux 系统在根目录（/）下一般会有哪些目录，它们分别有什么作用？
ans1:

/bin，包含二进制可执行文件的目录，存放常用可执行命令的目录。如常用的单用户模式下所需要的 Linux 命令，其他多用户需要的命令，比如 ps,ls,grep 等。
/sbin，管理类的命令，通常是系统管理员使用的，比如iptables,reboot,fdisk,ifconfi等。
/lib，存放系统库文件，为/bin或/sbin文件夹中的二进制程序提供必需的库文件，如ld*或者lib*.so.*
/etc，配置文件的存放位置，该目录下的配置文件是针对系统层级的，如果是个人配置，则在其家目录中。
/usr，用户使用的应用和文件（非系统必需的），类似于 Windows 的 Program File，存放默认安装文件存放的目录。一些非系统必需的用户应用存放在该目录中的/usr/bin中，非系统必需的系统应用存放在/usr/sbin中，它们所需要的库存在在/usr/lib中。
/boot，引导文件，如 bootloader(grub)，与系统启动相关；Linux 内核文件（kernel）也在该目录下。一般情况不要修改该目录下的文件，否则可能会导致系统无法启动。
/dev，设备文件所在目录，包含有代表硬件设备的特殊文件。比如/dev/sda表示系统中第一个SATA盘。该目录也会包含一些虚拟设备，比如/dev/null表示一个虚拟的设备，你把输出内容存到该设备中，就意味着你丢弃了你的输出内容。
/root，存放root用户相关文件的目录
/home，/root，用户主目录，存放普通用户相关文件的目录
/misc，杂项
/opt，option，有些第三方软件，把此目录当作默认安装位置
/proc，内存中的内核相关信息的映射，包含系统进程的信息，比如可以通过pid在此目录下查看相关进程信息，/proc/{pid}
/sys，像磁盘这样的存储设备或某些总线设备的驱动程序相关属性信息；
/srv，service，服务运行中中间的存放位置；
/tmp，存放临时文件的目录
/var： 存放一些经常变化的数据，一些文件随时变化的，比如系统日志/var/log等，可以在此目录下查看。还有包和数据库文件/var/lib，网页服务数据 /var/www，电子邮件/var/email，打印队列/var/spool等。
/mnt，临时挂载点目录，如默认挂载软驱、光驱的目录。在 WSL 中，在此目录下可以找到 Windows 的盘符，进入 Windows 系统文件。
/media，可移除媒体挂载目录，比如你将一个 CD 插入 Linux 系统中，在此目录下会自动生成一个可以访问该 CD 内容的子目录。
参考资料：

https://www.linux.com/blog/learn/intro-to-linux/2018/4/linux-filesystem-explained
https://www.tecmint.com/linux-directory-structure-and-important-files-paths-explained/
9. 什么是 Linux 系统的内核，如何查看内核版本号？
Linux 内核是底层系统，负责应用和硬件的接口调用，如果没有内核，应用将无法调用物理硬件。Linux内核属于monolithic型的内核，包括了CPU、内存、IPC、设备驱动、文件系统等。内核是整个操作系统的心脏，也是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层。

Linux内核版本有两种：稳定版（次版本为偶数）和开发版（次版本为奇数）

版本号：主版本.次版本.释出版本-修改版本

查看内核版本：

uname -a；uname -r
cat /proc/version
使用ls /boot可以看到vmlinuz-2.6.32-754.10.1.el6.x86_64类似的文件，这实际上就是Linux的内核
查看distribution版本：cat /etc/issue或者cat /etc/redhat-release（cat /etc/centos-release）
参考资料：

https://en.wikipedia.org/wiki/Linux_kernel
https://zh.wikipedia.org/zh-hans/Linux内核
https://itsfoss.com/find-which-kernel-version-is-running-in-ubuntu/
https://www.howtogeek.com/howto/31632/what-is-the-linux-kernel-and-what-does-it-do/
https://www.kernel.org/
https://www.cyberciti.biz/tips/compiling-linux-kernel-26.html
10. 在 Linux 下如何查看电脑的硬件信息（如内存、CPU、硬盘、显卡等）
CPU，lscpu；cat /proc/cpuinfo |grep "model name" && cat /proc/cpuinfo |grep "physical id"
内存，free -m；cat /proc/meminfo |grep MemTotal
硬盘，lsblk；df -h
显卡，lspci | grep -i vga
USB，lsusb
lspci 可以用于查看 PCI 设备，包括 USB、显卡、网卡、声卡等硬件

参考资料：

https://vitux.com/get-linux-system-and-hardware-details-on-the-command-line/
https://www.tecmint.com/commands-to-collect-system-and-hardware-information-in-linux/
https://www.binarytides.com/linux-commands-hardware-info/
https://www.maketecheasier.com/check-hardware-information-linux/
https://askubuntu.com/questions/31618/how-can-i-find-my-hardware-details
11. 在Linux 需要使用哪些命令来挂载一个移动硬盘？如果挂载时报错，一般会有哪几种情况？分别怎么解决？
Linux下，mount挂载的作用，就是将一个设备（通常是存储设备）挂接到一个已存在的目录上。访问这个目录就是访问该存储设备。

手动挂载移动硬盘的步骤：

首先切换至 root 权限
输入 fdisk-l，查询当前外部设备（移动硬盘）的标识符，如 /dev/sdb
新建挂载点 mkdir /mnt/hddisk1
挂载，如 mount /dev/sdb1 /mnt/hddisk1；NTFS 格式硬盘，mount -t ntfs-3g /dev/sdd1 /mnt/bbj
数据传输和修改，rsync、cp、mv等一系列操作
df -hl；查看硬盘容量
卸载移动硬盘，umount /mnt/bbj； umount -lf /mnt/bbj 进行强制卸载（当有程序占用时谨慎使用）
可能出现的错误：

非管理员权限进行 mount 操作
当使用umount命令卸载挂载点时，会遇到“device is busy”提示，可以进行如下操作：
sync；echo 3 > /proc/sys/vm/drop_caches；同步传输数据；
fuser 可以显示出当前哪个程序在使用磁盘上的某个文件、挂载点、甚至网络端口，并给出程序进程的详细信息.
fuser -m -v /dev/sdd：查看一下哪个用户哪个进程占用着此设备 ；
fuser -m -v -k /dev/sdd ：杀掉占用此设备的进程 ；
umount /mnt/bbj；卸载移动硬盘；
mount: /dev/sdb1 is write-protected, mounting read-only，该移动硬盘已经被挂载，可以使用 mount --bind /mnt/m1 /mnt/3 进行多重挂载
如果目录没有被挂载过，使用 umount 会出现 umount: /dev/sdb: not mounted 错误提示
挂载后没有在目录找到原本想要的文件，可能是该移动硬盘有多个分区，可以尝试依次挂载 /dev/sdb1，/dev/sdb2等等
如果移动硬盘在 Windows 系统下没有被正常卸载，挂载时会出现提示符，Linux 系统会自动修复后进行正常挂载操作
参考资料：

https://mp.weixin.qq.com/s/oReH2JDb4sc8rftesoEOlw
https://www.codero.com/knowledge-base/content/30/111/en/how-do-i-add-a-new-hard-drive-in-linux.html
https://unix.stackexchange.com/questions/18925/how-to-mount-a-device-in-linux
https://www.makeuseof.com/tag/mounting-hard-disks-partitions-using-linux-command-line/
https://linuxconfig.org/how-to-move-var-directory-to-another-partition
https://linuxize.com/post/how-to-mount-and-unmount-file-systems-in-linux/
https://serverfault.com/questions/67038/how-do-i-mount-sub-directory-to-a-hard-drive-in-linux
https://askubuntu.com/questions/125257/how-do-i-add-an-additional-hard-drive
12. Linux 系统中的 644、755、777 文件权限分别表示什么意思？他们的数字是怎么计算得来的？修改文件权限的命令是什么？怎么设置用户文件的默认权限？
444 r--r--r--
600 rw-------
644 rw-r--r--
666 rw-rw-rw-
700 rwx------
744 rwxr--r--
755 rwxr-xr-x
777 rwxrwxrwx
644：拥有者可读可写，其他人仅可读；
755：拥有者可读可写可执行，其他人仅可读可执行，不可写；
777：所有人均可读可写可执行。
从左至右，1-3 位数字代表文件所有者的权限，4-6 位数字代表同组用户的权限，7-9 数字代表其他用户的权限。而具体的权限是由数字来表示的，读取的权限等于 4，用 r 表示；写入的权限等于 2，用 w 表示；执行的权限等于 1，用 x 表示；

通过4、2、1的组合，得到以下几种权限：0（没有权限）；4（读取权限）；5（4+1 | 读取+执行）；6（4+2 | 读取+写入）；7（4+2+1 | 读取+写入+执行）

通过4、2、1的组合，得到以下几种权限：

0 (没有权限 )；4 (读取权限)；5( 4+1 | 读取+执行)；6(4+2 | 读取+写入)；7(4+2+1 | 读取+写入+执行)

每一个文件或者文件夹都有8个数字来控制权限。“100”（4）表示可读，“010”（2）表示可写，“001”（1）表示可执行。故多种权限组合时，有：

0 - 没有权限
1 - 可执行
2 - 可写
3 - 可写可执行
4 - 可读
5 - 可读可执行
6 - 可读可写
7 - 可读可写可执行
以755为例： 1-3位7等于4+2+1，rwx，所有者具有读取、写入、执行权限； 4-6位5等于4+1+0，r-x，同组用户具有读取、执行权限但没有写入权限； 7-9位5，同上，也是r-x，其他用户具有读取、执行权限但没有写入权限。 使用sudo chmod -（代表类型）×××（所有者）×××（组用户）×××（其他用户修改权限

想要改文件的权限，只有管理员 root 和所有者才能修改：

用户权限可以使用chmod命令来修改（可以更改文件 9 个属性）。除了 0-8 的数字来表示控制权限外，还通常使用 u,g,o,a 来控制，分别表示“拥有者”，“组内其他成员”，“组外其他成员”，“全部用户”；使用“+”添加权限，使用“-”去除权限。如对一个文件设置所有人可读可写可执行。

chmod 777 tt.txt
# 或者
chmod a+rwx tt.txt
如果你想设置新创建文件的默认权限，可以使用 umask 来设置限制新建目录或文件的权限掩码，用于指定在新目录或文件的默认权限中删除哪些权限。当创建新目录或文件时，默认的初始权限由权限掩码决定。

bash 用户可以在~/.bashrc文件中配置 umask，zsh 用户可以在 ~/.zshrc 中配置。如设置为：umask 033，则新建的文件与目录去掉了本用户组和其他用户组人员的写权限和可执行权限。

配置完成后，用户每次登陆系统时都会自动执行 umask 命令，并自动设置权限掩码来限制新文件的权限。也可以手动执行 umask 命令来改变默认值。

参考资料：

https://www.cyberciti.biz/faq/linux-list-all-members-of-a-group/
https://www.howtogeek.com/howto/ubuntu/see-which-groups-your-linux-user-belongs-to/
https://www.guru99.com/file-permissions.html
https://www.linode.com/docs/tools-reference/linux-users-and-groups/
https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Step_by_Step_Guide/s1-navigating-ownership.html
https://www.digitalocean.com/community/tutorials/an-introduction-to-linux-permissions
https://www.pluralsight.com/blog/it-ops/linux-file-permissions
https://www.geeksforgeeks.org/permissions-in-linux/
13. rsync，scp 都可以用来在服务器之间传输文件，它们的主要区别是什么？
scp 就是 secure copy，是用来进行远程文件拷贝的。数据传输使用 ssh，并且和 ssh 使用相同的认证方式，提供相同的安全保证。
rsync 是类 unix 系统下的数据镜像备份工具，从软件的命名上就可以看出来了，remote sync。它的操作方式和 scp 和相似，但是比 scp 强大很多。使用双冒号分割主机名和文件路径时，是使用 rsync 服务器，这里不做介绍。
scp 简单方便，安全可靠；支持限速参数，不支持排除目录。
scp 只能做全量备份。简单说就是 rsync 只传修改了的部分，如果改动较小就不需要全部重传，所以 rsync 备份速度较快。
rsync 有更多的参数可以选择，功能更加丰富，操作类似 scp，支持排除目录，支持限速参数；还支持本地复制。
rsync 只对差异文件做更新，可以做增量或全量备份，传输中断后，scp不能从断点续传，rsync可以断点续传，并检查文件是否正确传输；所以如果文件很大，或者网络很不稳定，最好使用rsync来传输。
默认情况下，rsync 通过比较文件的最后修改时间（mtime）和文件的大小（size）来确认哪些文件需要被同步过去。
rsync 是分块校验+传输，scp 是整个文件传输。rsync 比 scp 有优势的地方在于单个大文件的一小部分存在改动时，只需传输改动部分，无需重新传输整个文件。如果传输一个新的文件，理论上rsync没有优势。
rsync 不是加密传输，而 scp 是加密传输，使用时可以按需选择。
scp 命令格式：scp [参数] <源地址（用户名@IP地址或主机名）>:<文件路径> <目的地址（用户名 @IP 地址或主机名）>:<文件路径>
rsync 命令格式：rsync [参数] <源地址（用户名@IP地址或主机名）>:<文件路径> <目的地址（用户名 @IP 地址或主机名）>:<文件路径>
参考资料：

https://stackoverflow.com/questions/20244585/how-does-scp-differ-from-rsync
https://www.quora.com/What-is-the-difference-between-scp-and-rsync
https://superuser.com/questions/393608/difference-between-scp-and-rsync
https://unix.stackexchange.com/questions/39718/is-there-ever-a-reason-to-use-scp-instead-of-rsync
https://serverfault.com/questions/194514/rsync-and-scp-differences
https://medium.com/@elngovind/understanding-rsync-and-scp-46bcb20791d0
14. 在命令行界面，如何用 Vim 编辑器打开一个文本文件、创建一个文件、对文件进行修改和保存？
ans1:

使用vim 文件名即可。

如果该文件存在，那么在打开该文件，如果该文件不存在，那么将新建一个文件打开。退出 vim 有以下几种情况：

:q  -  退出vim
:q! -  不保存退出
:wq -  保存并退出
创建文件：vim test.txt，只要按下 i, o, a 等字符就可以进入输入模式，输入 :wq 即可保存离开

参考资料：

https://medium.com/actualize-network/how-to-learn-vim-a-four-week-plan-cd8b376a9b85/
https://www.openvim.com/
https://www.labnol.org/internet/learning-vim-for-beginners/28820/
https://vim-adventures.com/：玩游戏学vim
https://github.com/damassi/learn-vim
https://github.com/dofy/learn-vim
https://www.quora.com/What-is-the-best-way-to-learn-Vim-What-sites-and-resources-would-you-recommend-to-learn-efficiently
https://hackernoon.com/learning-vim-what-i-wish-i-knew-b5dca186bef7?gi=b90263ad2c36
15. 什么是 stderr 和 stdout？
stdout 是标准输出流，它显示来自命令的输出。它的文件描述符为 1。 stderr 是标准错误流，它显示来自命令的错误输出。它的文件描述符为 2

16. 管道在 Shell 中是一个什么样的角色？
管道使命令的语法紧凑并且使用简单；将多个命令串联，可以完成复杂的任务。

Shell 中管道（pipe）是将某个程序的标准输出作为另一个程序的标准输入。管道符号可以多个连用，它们之间相互独立，不会相互干扰。

示例如下：

program1 | program2 | program3 |...| programN
参考资料：

https://swcarpentry.github.io/shell-novice/04-pipefilter/index.html
https://en.wikipedia.org/wiki/Pipeline_(Unix)
https://ryanstutorials.net/linuxtutorial/piping.php
https://bash.cyberciti.biz/guide/Pipes
https://stackoverflow.com/questions/13417278/piping-in-a-basic-shell-implementation
17. 如何使用管道将上游的数据传入 Vim 编辑器？
grep -v "localhost" /etc/hosts | vim –`
cat aa.txt | vim -

# 或者
vim <(cat aa.txt)
18. 如何将程序的 stdout 和 stderr 通过管道输出到两个文件？
这涉及到输出的重导向，分别用1和2将标准输出和标准错误输出到两个文件中

# 把标准错误输出到stderr.txt
cat example.txt 2>stderr.txt

# 把标准输出输出到stdout.txt
cat example.txt 1>stdout.txt

# 把标准错误以标准输出形式输出
cat example.txt 2>&1

# 把标准输出以标准错误形式输出
cat example.txt 1>&2
参考资料：

https://mp.weixin.qq.com/s/_MLfjwcXrVo3H9V6iwbGew
https://www.jstorimer.com/blogs/workingwithcode/7766119-when-to-use-stderr-instead-of-stdout
https://my.oschina.net/qihh/blog/55308
https://www.zhihu.com/question/24030687
https://stackoverflow.com/questions/16497317/piping-both-stdout-and-stderr-in-bash
http://note.qidong.name/2017/07/bash_stdout_stderr/
https://blog.csdn.net/wangyeqiang/article/details/38726433
http://www.01happy.com/linux-stdin-stdout-stderr/
https://zh.wikipedia.org/zh/標準串流
19. 如何查看隐藏文件
l.
ls -d .*
ls -a
20. 如何使用 ROOT 权限？如何切换不同的身份
sudo 可以使非管理员执行需要root权限的操作；使用su可以进行不同身份的切换。

sudo mount /dev/sdb1 /mnt/m1

su root；su username`
$变成了#，说明现在是使用 root 用户

21. 如果输入的shell脚本过长，快速删除有哪些快捷键呢？如何快速调整光标位置
Ctrl + l 清屏
Ctrl + a：移到行首（a是首字母）
Ctrl + e：移到行尾（结束）
Ctrl + xx：行首到当前光标替换
Ctrl + u: 从光标所在位置一直删除到开头
Ctrl + k: 从光标所在位置一直删除到尾
Ctrl + a 移动光标到行首
Ctrl + e 移动光标到行尾
Ctrl + b 往后移动一个字符
Ctrl + f 往前移动一个字符
Ctrl + A：光标跳到命令行起始位置
Ctrl + E：光标跳到命令行末尾位置
Ctrl + B：向后移动一个字符
Ctrl + F：向前移动一个字符
Alt + 左箭头：向前移动一个单词
Alt + 右箭头：向后移动一个单词
22. Linux 文件操作时，比较 awk/grep/sed 三剑客的用法
grep 更适合单纯的查找或匹配文本，sed 更适合编辑匹配到的文本，awk 更适合格式化文本，对文本进行较复杂格式处理。

三个命令的运用形式：

grep    '字符'       文件
 sed     '命令'       文件
 awk    '条件{命令}'   文件

awk ‘{}’ file

grep this file

sed ‘2a hello’ file
参考资料：

https://www.jianshu.com/p/b3574d31f579
https://www.jianshu.com/p/879e22bedfb8
https://www.jianshu.com/p/9fcda404d9e1
https://www-users.york.ac.uk/~mijp1/teaching/2nd_year_Comp_Lab/guides/grep_awk_sed.pdf
https://thief.one/2017/08/12/1/
https://segmentfault.com/a/1190000015885994
https://unix.stackexchange.com/questions/2434/is-there-a-basic-tutorial-for-grep-awk-and-sed
https://stackoverflow.com/questions/7727640/what-are-the-differences-among-grep-awk-sed
http://blog.cee.moe/a-brief-introduction-to-grep-awk-and-sed.html
https://www.jianshu.com/p/3af864e9cb5a
23. Linux 系统中哪个文件是黑洞，可以吃掉 Shell 管道中流动的信息
/dev/null 通常用来处理进程中那些不想要的输出流，或者作为一个方便的空文件给输入流。这个通过用来做重定向。

参考资料：

https://askubuntu.com/questions/12098/what-does-outputting-to-dev-null-accomplish-in-bash-scripts
https://zh.wikipedia.org/wiki//dev/null
http://blog.jobbole.com/109355/
24. Linux 系统如何设置开机自动挂载（mount）你的移动介质（如U盘、移动硬盘）
将分区信息写到 /etc/fstab 文件中即可实现系统启动的自动挂载

fdisk -l                       # 查看可挂载的磁盘
df -h                          # 查看已经挂载的磁盘
mkfs.ext4 /dev/vdb             # 初始化磁盘
mount /dev/vdb /u01            # mount 磁盘到/u01，保证/u01为空
blkid                          # 获取磁盘的uuid和属性，用uuid来进行开机mount
vim /etc/fstab                 # 开机mount，模板是UUID=********** /u01  ext4  defaults  1 1
参考资料：

https://blog.csdn.net/qq_41116956/article/details/82767764
https://qiita.com/chinaperfirect/items/a525e4db0fae036b94f5
https://wiki.archlinux.org/index.php/Fstab_(简体中文)
https://en.wikipedia.org/wiki/Fstab
https://blog.51cto.com/zkxfoo/1758529
https://help.ubuntu.com/community/Fstab
http://man7.org/linux/man-pages/man5/fstab.5.html
https://www.howtogeek.com/howto/38125/htg-explains-what-is-the-linux-fstab-and-how-does-it-work/
25. 如何组装服务器和安装 Linux 系统
对于大型服务器的配置，新手用户建议通过服务器代理公司进行（通常会提供各类技术服务）。很多商业公司会通过租公有云服务器搭建动态集群来应对业务量的变化。

小型实体服务器则需要分别采购机箱、电源、CPU、内存、硬盘（SSD、机械硬盘等）、网卡、网络交换机。有可能还需要组装硬盘阵列。自己组装服务器，硬盘文件系统和网络系统是最容易出问题的部分。

Linux 系统安装见问题 3。

参考资料：

http://www.elecfans.com/emb/danpianji/20180814728842.html
https://jingyan.baidu.com/article/ed2a5d1f8e608209f6be1798.html
26. Linux有哪些常见系统，以及它们的区别是什么
见题 2 。

27. Linux三剑客是哪三个，常用命令有哪些
见题 22 。

28. Windows 子系统（WSL）的安装目录如何从迁移？
所有从商店安装的发行版都存在于以下目录中，C:\Users\<username>\AppData\Local\Packages。手动安装参考：https://damsteen.nl/blog/2018/08/29/installing-wsl-manually-on-non-system-drive

迁移 WSL 安装目录的方法：

查看当前用户名；在迁移目标磁盘创建一个文件夹 ，并设置权限；
下载 LxRunOffline；lxrunoffline list
查看已安装的Linux发行版本；
lxrunoffline move 迁移Linux文件；
lxrunoffline get-dir -n Ubuntu 查看新的安装目录
参考资料：

https://superuser.com/questions/1113906/can-i-move-the-linux-subsystem-to-a-different-drive
https://stackoverflow.com/questions/38779801/move-wsl-bash-on-windows-root-filesystem-to-another-hard-drive
29. WSL 如何自动挂载硬盘使其目录保持 755，文件保持 644 权限？
首先，需要在 /etc/wsl.conf 进行配置：

[automount]
options = "metadata,umask=0022,fmask=0133"
mountFsTab = true
然后，在 /etc/fstab 配置自动挂载：

C: /mnt/c drvfs metadata,uid=1000,gid=1000,umask=022,fmask=033 0 0
D: /mnt/d drvfs metadata,uid=1000,gid=1000,umask=022,fmask=133 0 0
注意：第三方终端安装在哪个盘，该 fmask 就设置为 033，否则会出现使用系统终端可以启动 WSL 系统，而用第三方终端则不行。

参考资料：

https://superuser.com/questions/1275940/wsl-mounted-file-permissions
https://devblogs.microsoft.com/commandline/chmod-chown-wsl-improvements/
http://zuyunfei.com/2018/06/15/file-system-configuration-in-wsl/
30. 如何批量修改某个目录下的目录权限为 755，文件权限为 644
find ./ -type f -print |xargs chmod 644
find ./ -type d -print|xargs chmod 755

ls -d */ | xargs -I {} chmod 755 {}
ls -p | grep -v / | xargs -I {} chmod 644 {}
31. 在 Windows 桌面环境直接编辑 WSL 内的目录和文件（自动挂载的目录和文件除外）有什么后果？
可能会造成权限错误，在 WSL 环境下无法访问、修改该文件内容。

32. 如何设置 Vim 编辑器，使其支持：a) 文件/目录路径提示和自动补全； b) Python 函数自动补全；c) 左侧显示目录树；d) 各种文件的语法高亮
首先，安装 Vundle 插件

git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim #安装vundle
cd ~
vi .vimrc
然后，配置 ~/.vimrc：

if &compatible
  set nocompatible
end

filetype off
set rtp+=~/.vim/bundle/vundle/
call vundle#rc()

# Let Vundle manage Vundle
Bundle 'gmarik/vundle'

# Define bundles via Github repos
# 标签导航
Bundle 'majutsushi/tagbar'
Bundle 'vim-scripts/ctags.vim'
# 静态代码分析
Bundle 'scrooloose/syntastic'
# 文件搜索
Bundle 'kien/ctrlp.vim'
# 目录树导航
Bundle "scrooloose/nerdtree"
# 美化状态栏
Bundle "Lokaltog/vim-powerline"
# 主题风格
# python自动补全 -->
Bundle 'davidhalter/jedi-vim'
Bundle "klen/python-mode"
# 括号匹配高亮 -->
Bundle 'kien/rainbow_parentheses.vim'
# 可视化缩进
Bundle 'nathanaelkane/vim-indent-guides'
if filereadable(expand("~/.vimrc.bundles.local"))
  source ~/.vimrc.bundles.local
endif

filetype on
最后，进入 vim 安装插件

:PluginInstall 安装插件等待 Done

参考资料：

https://github.com/VundleVim/Vundle.vim
https://medium.com/@huntie/10-essential-vim-plugins-for-2018-39957190b7a9
https://www.slant.co/topics/1224/~best-plugin-managers-for-vim
https://www.slant.co/versus/4081/17720/~pathogen_vs_asyncrun-vim
https://stackshare.io/stackups/neobundle-vs-vim-plug-vs-vundle
https://www.ostechnix.com/manage-vim-plugins-using-vundle-linux/
33. 什么是 X server?
Unix 及类 Unix 系统上的图形用户界面称为 X。X是用来图形化显示的一个程序，它以服务器的形式工作，可以在本地电脑运行，通过本地和服务器之间的联系可以在本地图形化显示。

X server 是 Linux 系统里面图形接口服务器的简称。X server 管理客户端的硬件，包括接收键盘/鼠标等设备的输入信息，并且将图形绘制在屏幕上。Windows 系统的界面是这个系统不可分割的一部分，各种窗口操作界面显示都是由系统核心直接管理的，而 Linux 的图形界面并不是系统的必要组成部分，它可以在无界面的条件下运行。当需要 Linux 提供界面的时候，系统就会建立一个或者数个 X server，通过 X 协议跟窗口管理器交互，由独立于系统的应用程序来产生窗口，状态栏，按钮之类的交互界面。

参考资料：

https://en.wikipedia.org/wiki/X_server
https://zh.wikipedia.org/wiki/X_Window系統
https://blog.csdn.net/vic_qxz/article/details/79073558
34. Manjaro Deepin Linux 是一个什么样的存在？
Manjaro 是一款基于 Arch 的带 Deepin 外壳的操作系统，它是近年来最火热的桌面 Linux 操作系统之一（https://distrowatch.com/dwres.php?resource=popularity）。它默认支持多种桌面环境和窗口管理界面，并分别提供 ISO安装镜像（XFCE、KDE、Cinnamon、GNOME、MATE，以及 Deepin）。并且原生使用 Arch 的 Pacman 进行软件滚动安装，可以让你方便、稳定的用上最新的软件包。

参考资料：

https://www.manjaro.cn/
https://www.manjaro.org/
http://www.mamicode.com/info-detail-2359428.html
35. Centos 系统如何开放指定端口的入和出的访问？
修改设置文件/etc/sysconfig/selinux

SELINUX=disabled
SELINUXTYPE=targeted
重启系统 然后修改iptables

iptables -A INPUT -m state --state NEW -p tcp --dport 8080 -j ACCEPT
sudo service iptables save
如果是使用 firewall ：

查询已开放的端口：netstat -anp
查询指定端口是否已开：firewall-cmd --query-port=666/tcp
添加指定需要开放的端口：firewall-cmd --add-port=123/tcp --permanent
重载入添加的端口：firewall-cmd --reload
查询指定端口是否开启成功：firewall-cmd --query-port=123/tcp
移除指定端口：firewall-cmd --permanent --remove-port=123/tcp
参考资料：

http://ask.xmodulo.com/open-port-firewall-centos-rhel.html
https://stackoverflow.com/questions/19034542/how-to-open-port-in-centos
https://www.rootusers.com/how-to-open-a-port-in-centos-7-with-firewalld/
36. Centos 和 Ubuntu 系统如何查看当前服务器的 IP 地址和 MAC 地址?
ifconfig
ifconfig -a
参考资料：

https://unix.stackexchange.com/questions/39501/difference-between-ifconfig-and-ipconfig
https://www.zhihu.com/question/21331450
https://blog.csdn.net/tanga842428/article/details/79405451
37. Centos 和 Ubuntu 系统如何查看即时网速？
sudo watch -n 1 "/sbin/ifconfig eth0 | grep bytes"

sudo apt install nethogs / sudo yum install nethogs
nethogs eth0
参考资料：

https://www.binarytides.com/linux-commands-monitor-network/
https://www.cyberciti.biz/faq/howto-determine-ethernet-connection-speed/
http://www.aboutlinux.info/2005/10/find-speed-of-your-ethernet-card-in.html
https://unix.stackexchange.com/questions/172573/determine-ethernet-speed-in-rhel-6
https://www.maketecheasier.com/monitor-network-bandwith-linux/
38. 如果你没有买域名，如何在本地模拟某个域名的访问？
Windows 用户修改 C:\Windows\System32\drivers\etc\hosts
Linux 用户修改 /etc/hosts
# 如模拟 life2cloud.com 访问
127.0.0.1   life2cloud.com
参考资料：

https://en.wikipedia.org/wiki/Hosts_(file)
https://baike.baidu.com/item/hosts/10474546
https://gist.github.com/zenorocha/18b10a14b2deb214dc4ce43a2d2e2992
https://www.cnblogs.com/itfat/p/9212698.html
http://piaoyi.org/computer/hosts-path.html
https://jingyan.baidu.com/article/9f7e7ec04dacc06f281554dd.html
39. 如何查看并设置当前环境的语言？en_us.utf-8 和 zh_cn.utf-8 分别代表什么？
# 使用 `locale` 查看当前语言环境
locale

echo $LANG；
## en_US.UTF-8：你说英语，你在美国，字符集是utf-8
## zh_CN.UTF-8：你说中文，你在中国，字符集是utf-8

# 设置中文环境

export LC_ALL=zh_CN.UTF-8

# 设置英文环境

export LC_ALL=en_US.UTF-8

## en_US.UTF-8、zh_CN.UTF-8叫做字符集，就是说‘A’、‘B’、‘中’、‘国’等对应的整数值，en_US.UTF-8只包含了ASCII码，zh_CN.UTF-8包含了6000多个汉字
语言环境定义来所在环境的时间、日期格式、货币符号等人们的常用表达习惯。en_us.utf-8表示美式英语环境，zh_cn.utf-8表示中文环境。如在en_us.utf-8中货币符号表示为$，而在zh_cn.utf-8中则表示为¥。

参考资料：

https://stackoverflow.com/questions/21153485/what-is-the-different-of-zh-cn-utf-8-and-en-us-utf-8-in-nix-locale-setting
https://www.cnblogs.com/R-zqiang/archive/2012/11/23/2785125.html
https://docs.oracle.com/cd/E19455-01/806-0169/6j9hsml3j/index.html
https://blog.csdn.net/yunhuang2010/article/details/8109578
http://www.cnblogs.com/hubery/p/5973281.html
40. 如何新增一个用户并赋予该用户 root 权限？
# 添加用户
adduser eric

# 初始化密码
passwd eric

## Changing password for user eric.
## New UNIX password:   //在这里输入新密码
## Retype new UNIX password: //再次输入新密码
## passwd: all authentication tokens updated successfully.
修改用户 sudo 权限：

# 方法一：修改 /etc/sudoers 文件，找到下面一行，把前面的注释（#）去掉
adduser username；

## Allows people in group wheel to run all commands

%wheel    ALL=(ALL)    ALL

## 然后修改用户，使其属于root组（wheel），命令如下：

usermod -g root username

## 修改完毕，现在可以用新帐号登录，然后用命令 su – ，即可获得root权限进行操作。

# 方法二：修改 /etc/sudoers 文件，找到下面一行，在root下面添加一行，如下所示：
## Allow root to run any commands anywhere
root    ALL=(ALL)     ALL
username   ALL=(ALL)     ALL

# 方法三：修改 /etc/passwd 文件，找到如下行，把用户ID修改为 0 ，如下所示：
username:x:0:33:username:/data/webroot:/bin/bash
如果你希望用户在使用 sudo 权限时不需要输入密码，可以将

username ALL=(ALL) ALL 修改为 username ALL=(ALL) NOPASSWD: ALL

参考资料：

https://linuxhandbook.com/useradd-vs-adduser/
https://askubuntu.com/questions/345974/what-is-the-difference-between-adduser-and-useradd
http://www.linuxso.com/command/useradd.html
http://www.runoob.com/linux/linux-comm-adduser.html
https://www.tecmint.com/add-users-in-linux/
https://www.garron.me/en/go2linux/useradd-vs-adduser-ubuntu-linux.html
41. 跟 nano 相比，vim 的优势在哪里？在 vim 里，p 与 P 两种指令下粘贴的效果有什么区别？
nano 简洁，vim 强大。vim 相当于 nano 的升级版，有一定学习难度。vim 能够实现的功能也更加丰富一些，比如可以分割窗口、语法高亮等。如果你下定决心想学习 Linux 系统，建议你先把 vim 编辑器作为必学技能之一。

小写 p 代表贴至游标后（下），因为游标是在具体字符的位置上，所以实际是在该字符的后面；大写 P 代表贴至游标前（上）

42. 在vim中，编辑完文件后显示 E45: ‘readonly’ option is set 时，如何强制写入该档案并保存退出？
使用!强制保存并退出，:wq!

sudo vi /etc/crontab 命令打开文件，此时便是以 root 权限进入该文件。

# 退出文件使用 :wq! 就可以了。
编程题
1. 使用 bash 实现一个函数，输入整数 n，得到 1 到 n 的累加和
#read -p "n=" n
n=10
sum=0
i=1
while (($i<=$n))
do
sum=$(($sum +$i))
i=$(($i+1))
done
echo "n=$n； CUSUM=$sum"

# 方法1
#!/bin/bash
echo `expr $1 \* \( 1 + $1 \) / 2`

# 方法2
#!/bin/bash
score=0
for i in $(seq 1 $1)
do
score=`expr ${score} + ${i}`
done
echo ${score}
2. 通过 Shell 命令提取 gtf 中编码基因的 gene symbol 和 gene id
grep 'gene_biotype "protein_coding"' Homo_sapiens.GRCh38.89.chr.gtf | \
	  awk -F"[\t]" '{print $9}' | \
	  sed 's/； /\n/g' | \
	  awk 'BEGIN{printf "%10s %10s\n","gene_id","gene_name\n"} {if ($1=="gene_id") printf "%10s",$2；else if ($1=="gene_name") printf "%10s\n",$2}' | \
	  uniq >gtf_geneid_genesymbol.txt
3. 假设有如下文件 “sample.txt”，文件中包含有若干列重复列。请保留一列重复列，并不影响列顺序。
awk -F, 'NR==1{for(i=1；i<=NF；i++)if(!($i in v)){ v[$i]；t[i]}}{s=""； for(i=1；i<=NF；i++)if(i in t)s=s sprintf("%s,",$i)；if(s){sub(/,$/,"",s)；print s}} ' sample.csv
4. 使用 bash 编程实现时间戳功能，如下为 ngsjs 的 rtime_stamp 命令行程序（R语言）输出
$ rtime_stamp
[1] “2019_04_03_18_53_44_” “2019_04_03_18_53_” “2019_04_03_18_”
[4] “2019_04_03_” “2019_04_” “2019_”
[1] “2019-04-03-18-53-44-” “2019-04-03-18-53-” “2019-04-03-18-”
[4] “2019-04-03-” “2019-04-” “2019-”
[1] “2019/04/03/18/53/44/” “2019/04/03/18/53/” “2019/04/03/18/”
[4] “2019/04/03/” “2019/04/” “2019/”
$ rtime_stamp -r ‘x1’
2019_04_03_18_56_55_
2019_04_03_18_56_
2019_04_03_18_
2019_04_03_
2019_04_
2019_
$ rtime_stamp -r ‘x1[1]’
2019_04_03_18_57_18_
[yangyang@izuf6btm1dq2w64mt5q889z practice]$ date +%F-%H-%M-%S
2019-04-06-17-36-46
[yangyang@izuf6btm1dq2w64mt5q889z practice]$ date +%Y%M%d%H%M%S
20193906173947
5. 尝试使用源码编译安装最新版本的 R，记录过程中遇到的问题。同时使用系统自带的包管理器（如 centos 的yum；Debian/Ubuntu 的 apt；arch、manjaro 的 pacman）、conda 和 spack 安装相同版本的 R。
# 下载 R 源码包
cd /path/opt/
mkdir R
cd R
wget https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/base/R-3/R-3.5.3.tar.gz
下面是源代码包下载完成时的样子：

Resolving mirrors.tuna.tsinghua.edu.cn (mirrors.tuna.tsinghua.edu.cn)... 101.6.8.193, 2402:f000:1:408:8100::1
Connecting to mirrors.tuna.tsinghua.edu.cn (mirrors.tuna.tsinghua.edu.cn)|101.6.8.193|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 30205979 (29M) [application/x-gzip]
Saving to: ‘R-3.5.3.tar.gz’

R-3.5.3.tar.gz                  100%[======================================================>]  28.81M  5.64MB/s    in 5.2s

# 解压缩 tar.gz 格式的压缩文件
tar -xzvf R-3.5.3.tar.gz

# 进行 R 源码编译（之前已用 apt 安装过 R，所以很多依赖包已经安装完毕）
cd R-3.5.3

# 查看帮助
./configure --help

# 配置编译参数，并检查编译依赖库和变量是否存在
# 默认使用系统自带的 gcc 8.3 进行编译
# --with-x 与后续一些调用 X 窗口的包相关，一般建议添加
# --enable-R-shlib 可以使 R 的动态库共享，否则后续安装包可能会出现 Error in dyn.load
./configure --enable-prebuilt-html --with-x --with-blas --with-lapack --enable-R-shlib --prefix=`pwd`

# 之前我遇到过的错误包括 zlib、bzip2、xz、pcre、curl 依赖未符合要求
# 需要安装指定版本，并配置 CFLAGS（如 -I{{zlib:install.dir}}/include） 和 LDFLAGS （如-I{{bzip2:install.dir}}/lib）
如果你看到下面输出，说明可以继续往下做了

R is now configured for x86_64-pc-linux-gnu

  Source directory:          .
  Installation directory:    /usr/local

  C compiler:                gcc  -g -O2
  Fortran 77 compiler:       f95  -g -O2

  Default C++ compiler:      g++   -g -O2
  C++98 compiler:            g++ -std=gnu++98 -g -O2
  C++11 compiler:            g++ -std=gnu++11 -g -O2
  C++14 compiler:            g++ -std=gnu++14 -g -O2
  C++17 compiler:            g++ -std=gnu++17 -g -O2
  Fortran 90/95 compiler:    gfortran -g -O2
  Obj-C compiler:

  Interfaces supported:      X11
  External libraries:        readline, BLAS(generic), LAPACK(generic), curl
  Additional capabilities:   PNG, JPEG, TIFF, NLS, cairo, ICU
  Options enabled:           shared R library, R profiling, static HTML

  Capabilities skipped:
  Options not enabled:       shared BLAS, memory profiling

  Recommended packages:      yes

# 进行编译得到二进制程序
make

make install
conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换

# 安装Conda 
sudo yum install bzip2
wget -c https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh
chmod 777 Miniconda3-latest-Linux-x86_64.sh #给执行权限
bash Miniconda3-latest-Linux-x86_64.sh #运行

#安装R
conda search R
conda install r==3.5.1
Spack是一种主要针对超级计算机（High Performance Computing，HPC）运行环境开发的科学软件包管理器。如果你之前使用过conda，那么我非常推荐你在你的HPC环境上同时使用 Spack 工具，特别是针对某些运行时（runtime）不符合你预期的 conda 预编译程序。

目前可以运行在 Linux 和 macOS 操作系统的软件包管理器。它使安装科学软件变得容易。使用 Spack 可以构建具有多个版本，配置，平台和编译器的软件包，并且所有这些构建可以在同一台计算机上共存。

Spack 与特定语言无关; 您可以使用 Python 或 R 构建软件堆栈 ，链接到用C，C ++或Fortran编写的库，并轻松 交换编译器。使用 Spack 安装在主目录中， 管理群集上的共享安装和模块，或构建组合版本的软件以进行测试。

# 安装 spack
cd /path/opt
git clone https://github.com/spack/spack.git
. spack/share/spack/setup-env.sh

# 安装 environment-modules

sudo yum install -y environment-modules
sudo apt-get install environment-modules

# 如果需要登录自动配置，则需将下面的内容添加至 ~/.bashrc（BASH） 或 ~/.zshrc（ZSH）
# 查看 environment-modules 安装路径 /usr/share/Modules 或 /usr/share/modules
## source /usr/share/Modules/init/zsh
## source /usr/share/Modules/init/bash
## source /usr/share/modules/init/zsh
## source /usr/share/modules/init/bash

export SPACK_ROOT=/home/ljf/opt/spack
. $SPACK_ROOT/share/spack/setup-env.sh

# 安装 R
spack install r

# 指定 R 版本
spack install r@3.5.3

# 指定 R 版本，并指定编译器版本
# spack compilers 查看目前可用的编译器
# spack compilers find 搜索目前可用的编译器
spack install r@3.5.3 %gcc@8.3.0
6. 使用 spack 在指定不同版本的 gcc 编译器（如8.3、5.4 和 4.8）情况下安装最新版本的R。并比较一些 R 基础函数的速度在计算较大数据量时是否有变化。
# 查看已安装编译器版本
spack compilers

# 搜索已安装的编译器
spack compiler find

# 测试系统默认使用 gcc 8.3.0
# 所以我先安装 gcc 6.4.0 和 4.8.5
# 耗时较久
# 如果你使用的是自带 spack 的大型超算服务器
# 可以直接使用 module avail 和 module load 分别加载这些 gcc 编译器
spack install gcc@6.4.0 gcc@4.8.5

# 再不同版本的编译器下分别安装 R
spack install r@3.5.3 %gcc@8.3.0 > r_3.5.3_gcc_8_3_install.log &
spack install r@3.5.3 %gcc@6.4.0 > r_3.5.3_gcc_6_4_0_install.log &
spack install r@3.5.3 %gcc@4.8.5 > r_3.5.3_gcc_4_8_5_install.log &

# 使用 module avail 查看已安装的 R
module avail

#> r-3.5.3-gcc-8.3-42ygaa5
#> r-3.5.3-gcc-6.4.0-xavmzr7
#> r-3.5.3-gcc-4.8.5-3zhievr

# 测试 cor 函数
# test_cor.R
dat_a <- 1:30000000
dat_b <- 1:30000000
for(i in 1:10) {
  print(system.time(cor(dat_a, dat_b)))
}

# 加载 R
module load r-3.5.3-gcc-4.8.5-3zhievr
Rscript test_cor.R

echo ""

module load r-3.5.3-gcc-6.4.0-xavmzr7
Rscript test_cor.R

echo ""

module load r-3.5.3-gcc-8.3-42ygaa5
Rscript test_cor.R

# cor
   user  system elapsed
  0.493   0.102   0.595
   user  system elapsed
  0.450   0.091   0.541
   user  system elapsed
  0.457   0.091   0.549
   user  system elapsed
  0.458   0.088   0.547
   user  system elapsed
  0.453   0.092   0.546
   user  system elapsed
  0.444   0.100   0.544
   user  system elapsed
  0.453   0.093   0.546
   user  system elapsed
  0.455   0.090   0.545
   user  system elapsed
  0.451   0.094   0.545
   user  system elapsed
  0.454   0.089   0.543

   user  system elapsed
  0.450   0.093   0.544
   user  system elapsed
  0.453   0.091   0.544
   user  system elapsed
  0.450   0.094   0.544
   user  system elapsed
  0.455   0.086   0.542
   user  system elapsed
  0.452   0.092   0.544
   user  system elapsed
  0.451   0.096   0.547
   user  system elapsed
  0.446   0.098   0.544
   user  system elapsed
  0.451   0.088   0.539
   user  system elapsed
  0.451   0.093   0.544
   user  system elapsed
  0.450   0.097   0.547

   user  system elapsed
  0.450   0.092   0.543
   user  system elapsed
  0.452   0.093   0.546
   user  system elapsed
  0.452   0.093   0.546
   user  system elapsed
  0.449   0.098   0.548
   user  system elapsed
  0.446   0.094   0.540
   user  system elapsed
  0.450   0.098   0.548
   user  system elapsed
  0.453   0.092   0.545
   user  system elapsed
  0.451   0.094   0.545
   user  system elapsed
   0.45    0.09    0.54
   user  system elapsed
  0.453   0.094   0.548

# 测试 t.test 函数
# test_t.R
dat_a <- 1:30000000
dat_b <- 1:30000000
for(i in 1:10) {
  print(system.time(t.test(dat_a, dat_b)))
}

# 加载 R
module load r-3.5.3-gcc-4.8.5-3zhievr
Rscript test_t.R

echo ""

module load r-3.5.3-gcc-6.4.0-xavmzr7
Rscript test_t.R

echo ""

module load r-3.5.3-gcc-8.3-42ygaa5
Rscript test_t.R

   user  system elapsed
  1.454   0.320   1.774
   user  system elapsed
  1.325   0.304   1.629
   user  system elapsed
  1.291   0.307   1.599
   user  system elapsed
  1.305   0.297   1.603
   user  system elapsed
  1.288   0.309   1.597
   user  system elapsed
  1.283   0.319   1.603
   user  system elapsed
  1.306   0.312   1.617
   user  system elapsed
  1.284   0.314   1.598
   user  system elapsed
  1.286   0.313   1.600
   user  system elapsed
  1.285   0.319   1.605

   user  system elapsed
  1.384   0.318   1.704
   user  system elapsed
  1.302   0.332   1.634
   user  system elapsed
  1.574   0.357   1.933
   user  system elapsed
  1.345   0.333   1.677
   user  system elapsed
  1.292   0.306   1.599
   user  system elapsed
  1.288   0.312   1.599
   user  system elapsed
  1.386   0.306   1.693
   user  system elapsed
  1.326   0.321   1.647
   user  system elapsed
  1.296   0.303   1.598
   user  system elapsed
  1.277   0.321   1.599

   user  system elapsed
  1.385   0.315   1.701
   user  system elapsed
  1.318   0.322   1.639
   user  system elapsed
  1.291   0.308   1.601
   user  system elapsed
  1.293   0.311   1.603
   user  system elapsed
  1.284   0.316   1.600
   user  system elapsed
  1.284   0.320   1.605
   user  system elapsed
  1.300   0.323   1.623
   user  system elapsed
  1.305   0.296   1.601
   user  system elapsed
  1.292   0.310   1.609
   user  system elapsed
  1.286   0.316   1.603

# 测试 lm 函数
# test_lm.R
dat_a <- 1:30000000
dat_b <- 1:30000000
for(i in 1:10) {
  print(system.time(lm(dat_a ~ dat_b)))
}

# 加载 R
module load r-3.5.3-gcc-4.8.5-3zhievr
Rscript test_lm.R

echo ""

module load r-3.5.3-gcc-6.4.0-xavmzr7
Rscript test_lm.R

echo ""

module load r-3.5.3-gcc-8.3-42ygaa5
Rscript test_lm.R

   user  system elapsed
  5.214   1.043   6.311
   user  system elapsed
  4.769   1.025   5.794
   user  system elapsed
  4.817   0.974   5.793
   user  system elapsed
  4.759   0.995   5.756
   user  system elapsed
  4.795   1.008   5.804
   user  system elapsed
  4.789   0.998   5.787
   user  system elapsed
  4.746   1.033   5.780
   user  system elapsed
  4.766   1.023   5.790
   user  system elapsed
  4.789   1.014   5.806
   user  system elapsed
  4.734   1.021   5.761

   user  system elapsed
  5.092   1.056   6.148
   user  system elapsed
  4.833   0.968   5.802
   user  system elapsed
  4.798   1.003   5.803
   user  system elapsed
  4.736   1.007   5.743
   user  system elapsed
  4.955   0.969   5.925
   user  system elapsed
  4.801   0.994   5.796
   user  system elapsed
  4.765   1.032   5.799
   user  system elapsed
  4.781   1.015   5.797
   user  system elapsed
  4.782   1.003   5.785
   user  system elapsed
  4.728   1.009   5.739

   user  system elapsed
  5.096   1.061   6.164
   user  system elapsed
  4.789   1.002   5.794
   user  system elapsed
  4.826   0.966   5.795
   user  system elapsed
  4.733   1.007   5.740
   user  system elapsed
  4.909   1.022   5.933
   user  system elapsed
  4.771   1.025   5.797
   user  system elapsed
  4.781   1.004   5.786
   user  system elapsed
  4.786   0.997   5.785
   user  system elapsed
  4.753   1.032   5.786
   user  system elapsed
  4.725   1.030   5.756
