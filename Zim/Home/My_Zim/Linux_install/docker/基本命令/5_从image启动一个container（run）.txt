Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2018-12-09T10:15:34+08:00

====== 5 从image启动一个container（run） ======
创建日期 星期日 09 十二月 2018

docker run命令首先会从特定的image创之上create一层可写的container，然后通过start命令来启动它。停止的container可以重新启动并保留原来的修改。run命令启动参数有很多，以下是一些常规使用说明，更多部分请参考  http://www.cnphp6.com/archives/24899
当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：

__检查本地是否存在指定的镜像，不存在就从公有仓库下载__
__利用镜像创建并启动一个容器__
__分配一个文件系统，并在只读的镜像层外面挂载一层可读写层__
__从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去__
__从地址池配置一个 ip 地址给容器__
__执行用户指定的应用程序__
__执行完毕后容器被终止__
Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

5.1 使用image创建container并执行相应命令，然后停止
# docker run ubuntu echo "hello world"
hello word
这是最简单的方式，跟在本地直接执行echo 'hello world' 几乎感觉不出任何区别，而实际上它会从本地ubuntu:latest镜像启动到一个容器，并执行打印命令后退出（docker ps -l可查看）。需要注意的是，默认有一个--rm=true参数，即完成操作后停止容器并从文件系统移除。因为Docker的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。
容器启动后会自动随机生成一个CONTAINER ID，这个ID在后面commit命令后可以变为IMAGE ID

使用image创建container并进入交互模式, login shell是/bin/bash
__# docker run -i -t --name mytest centos:centos6 /bin/bash__
bash-4.1#
上面的--name参数可以指定启动后的容器名字，如果不指定则docker会帮我们取一个名字。镜像centos:centos6也可以用IMAGE ID (68edf809afe7) 代替），并且会启动一个伪终端，但通过ps或top命令我们却只能看到一两个进程，因为容器的核心是所执行的应用程序，所需要的资源都是应用程序运行所必需的，除此之外，并没有其它的资源，可见Docker对资源的利用率极高。__此时使用exit或Ctrl+D退出后，这个容器也就消失了（消失后的容器并没有完全删除？）__
（那么多个TAG不同而IMAGE ID相同的的镜像究竟会运行以哪一个TAG启动呢

__5.2 运行出一个container放到后台运行__
# docker run -d ubuntu /bin/sh -c "while true; do echo hello world; sleep 2; done"
ae60c4b642058fefcc61ada85a610914bed9f5df0e2aa147100eab85cea785dc
它将直接把启动的container挂起放在后台运行（这才叫saas），并且会输出一个CONTAINER ID，
通过docker ps可以看到这个容器的信息，
可在container外面查看它的输出docker logs ae60c4b64205，
也可以通过docker attach ae60c4b64205连接到这个正在运行的终端，
此时在Ctrl+C退出container就消失了，按ctrl-p ctrl-q可以退出到宿主机，而保持container仍然在运行
另外，如果-d启动但后面的命令执行完就结束了，如/bin/bash、echo test，则container做完该做的时候依然会终止。而且-d不能与--rm同时使用
可以通过这种方式来运行memcached、apache等。

__5.3 映射host到container的端口和目录__
映射主机到容器的端口是很有用的，比如在container中运行memcached，端口为11211，运行容器的host可以连接container的 internel_ip:11211 访问，如果有从其他主机访问memcached需求那就可以通过-p选项，形如-p <host_port:contain_port>，存在以下几种写法：

-p 11211:11211 这个即是默认情况下，绑定主机所有网卡（0.0.0.0）的11211端口到容器的11211端口上
-p 127.0.0.1:11211:11211 只绑定localhost这个接口的11211端口
-p 127.0.0.1::5000
-p 127.0.0.1:80:8080
__目录映射其实是“绑定挂载”host的路径到container的目录，这对于内外传送文件比较方便__，在搭建私服那一节，为了避免私服container停止以后保存的images不被删除，就要把提交的images保存到挂载的主机目录下。使用比较简单，-v <host_path:container_path>，绑定多个目录时再加-v。

-v /tmp/docker:/tmp/docker
__另外在两个container之间建立联系可用--link__，详见高级部分或官方文档。
下面是一个例子：

# docker run --name nginx_test \
> -v /tmp/docker:/usr/share/nginx/html:ro \
> -p 80:80 -d \
> nginx:1.7.6
在主机的/tmp/docker下建立index.html，就可以通过 http://localhost:80/ 或  http://host-ip:80 访问了。
