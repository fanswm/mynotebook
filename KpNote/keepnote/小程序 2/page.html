<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>小程序</title>
</head><body><br/>
<br/>
<hr/><span style="color: #ff0000">页面标题：index.json:</span><br/>
{<br/>
&nbsp; "navigationBarTitleText": "文件存储指引",<br/>
&nbsp; "usingComponents": {}<br/>
}<br/>
<span style="color: #ff0000">全屏</span>：<br/>
"windows":{<br/>
&nbsp;"navigationStyle": "custom"<br/>
}<hr/><span style="color: #ff0000">//app.js</span><br/>
App({<br/>
&nbsp; onLaunch: function () {<br/>
&nbsp; &nbsp;//...<br/>
&nbsp; &nbsp; <span style="color: #ff0000">this.globalData = {}</span><br/>
&nbsp; }<br/>
})<hr/><span style="color: #ff0000">wx:if</span><br/>
&lt;text class="request-text" wx:for="{{7}}" style="color: {{step === index + 1 ? 'red': 'black'}}<hr/>分步显示：<br/>
&lt;view class="guide" <span style="color: #ff0000">wx:if="{{step === 7}}"</span>&gt;<ul><li style="list-style-type: none">&lt;view&gt;要显示的 <span style="color: #ff0000">第 7 步</span>&nbsp;的内容&lt;/view&gt;</li>
</ul>
&lt;/view&gt;<hr/><span style="color: #ff0000">button</span>: &nbsp;&lt;button class="prev" size="mini" type="default" bindtap="prevStep"&gt;上一步&lt;/button&gt;<br/>
&nbsp; &nbsp; &nbsp; &lt;button class="next" <span style="color: #ff0000">size</span>="mini" type="default" bindtap="nextStep"&gt;下一步&lt;/button&gt;<span style="color: #ff0000"></span><span style="color: #ff0000"><hr/></span><span style="color: #ff0000">wxss 样式优先级</span>：!important&#09;style=""&#09;#id&#09;.class&#09;element&#09;（级别： 无穷大；1000 递减10倍)。<ul><li style="list-style-type: none">page.wxss 会覆盖 app.wxss 中相同的选择器。</li>
</ul>
<hr/><span style="color: #ff0000">条件渲染</span>：<br/>
&lt;view wx:if="{{条件}}"&gt; 呈现&lt;/view&gt;<br/>
&lt;view wx:elif="{{条件2}}"&gt;呈现2&lt;/view&gt;<br/>
&lt;view wx:else="{{其他}}"&gt;其他&lt;/view&gt;<hr/><span style="color: #ff0000">css 选择器</span>：<br/>
&nbsp; &nbsp; &nbsp; &nbsp;::after:<ul><li style="list-style-type: none">&lt;view&gt;这是view.&lt;/view&gt;</li>
<li style="list-style-type: none">wxss:</li>
<li style="list-style-type: none">view:after {</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">content: '这是在view 后的内容'</li>
</ul>
</li>
<li style="list-style-type: none">}</li>
<li style="list-style-type: none">呈现：这是view.这是在view 后的内容</li>
<li style="list-style-type: none"></li>
</ul>
<span style="color: #ff0000">behaviors &nbsp;： </span>可以用来让多个页面有相同的数据字段和方法。<span style="color: #ff0000">用于组件间代码共享的特性</span>，类似于一些编程语言中的<span style="color: #ff0000">“mixins”或“traits”。</span><ul><li style="list-style-type: none">使用 Component 构造器来构造页面的一个<span style="color: #ff0000">好处是可以使用 behaviors 来提取所有页面中公用的代码段</span>。</li>
<span style="color: #ff0000"><li style="list-style-type: none">如果一个组件多次直接或间接引用同一个 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。</li>
</span><li style="list-style-type: none">内置 behavior （自定义组件：behaviors）</li>
</ul>
<br/>
<span style="color: #ff0000">样式隔离</span>&nbsp;： （自定义组件：组件模板与样式）<ul><li style="list-style-type: none">默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。除非以下两种情况：</li>
<li style="list-style-type: none">app.wxss 或页面的 wxss 中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。</li>
<li style="list-style-type: none">指定特殊的样式隔离选项 styleIsolation 。</li>
</ul>
<br/>
<span style="color: #ff0000">addGlobalClass 选项</span>： <br/>
<span style="color: #ff0000">组件样式隔离：</span><ul><li style="list-style-type: none">options: {</li>
</ul>
&nbsp; &nbsp; &#09;&#09;styleIsolation: 'isolated'<br/>
&nbsp;&#09; }<br/>
<span style="color: #ff0000">外部样式类</span>： <ul><li style="list-style-type: none">Component({</li>
<li style="list-style-type: none"><span style="color: #ff0000">&nbsp; externalClasses: ['my-class']</span></li>
<li style="list-style-type: none">})</li>
</ul>
<span style="color: #ff0000">引用页面或父组件的样式</span>：<ul><li style="list-style-type: none">&lt;view class="~blue-text"&gt; 这段文本是蓝色的 &lt;/view&gt;&#09;&#09;imrdr:引用页面样式；</li>
<li style="list-style-type: none">&lt;view class="^red-text"&gt; 这段文本是红色的 &lt;/view&gt;&#09;&#09;imrdr:引用父组件的样式；也可以连续使用<span style="color: #ff0000">多个 ^ 来引用祖先组件中的样式</span>。</li>
</ul>
<hr/><span style="color: #ff0000">仅在 480px 或更宽的屏幕上生效的样式规则: &nbsp;（框架：视图层：响应显示区域的变化）</span><br/>
<br/>
.my-class {<br/>
&nbsp; width: 40px;<br/>
}<br/>
<br/>
@media (min-width: 480px) {<br/>
&nbsp; /* 仅在 480px 或更宽的屏幕上生效的样式规则 */<br/>
&nbsp; .my-class {<br/>
&nbsp; &nbsp; width: 200px;<br/>
&nbsp; }<br/>
}<hr/><span style="color: #ff0000">API: </span>&#09;&#09;基础库 2.10.2 版本起，<span style="color: #ff0000">异步 API 支持 callback &amp; promise 两种调用方式</span>.<ul><li style="list-style-type: none">注意事项</li>
<li>部分接口如 downloadFile, request, uploadFile, connectSocket, createCamera（小游戏）本身就有返回值， 它们的 promisify 需要开发者自行封装。</li>
<li>当没有回调参数时，异步接口返回 promise。此时若函数调用失败进入 fail 逻辑， 会报错提示 Uncaught (in promise)，开发者可通过 catch 来进行捕获。</li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onUnhandledRejection.html">wx.onUnhandledRejection</a> 可以监听未处理的 Promise 拒绝事件。</li>
</ul>
&nbsp;<hr/><span style="color: #ff0000">事件系统 </span>：&#09;bind/catch/mut-bind&#09;&#09;（catch 会阻止事件冒泡。）冒泡：由内向外（上）；捕获则相反。<br/>
<ul><li style="list-style-type: none"><span style="color: #ff0000">capture-bind、capture-catch关键字</span></li>
<li style="list-style-type: none"><ul><li>，<span style="color: #ff0000">后者将中断捕获阶段和取消冒泡阶段</span>。</li>
<li style="list-style-type: none"></li>
</ul>
</li>
<li style="list-style-type: none">事件<span style="color: #ff0000">绑定函数可以是一个数据绑定</span>，如：&lt;view bindtap="{{ handlerName }}"&gt; &nbsp; &nbsp;Click here!&lt;/view&gt;此时，页面的 this.data.handlerName <span style="color: #ff0000">必须是一个字符串，</span>指定事件处理函数名；<span style="color: #ff0000">如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）</span>。</li>
<li style="list-style-type: none"></li>
</ul>
<span style="color: #ff0000">页面路由</span>：<span style="color: #ff0000">页面跳转</span>&nbsp; 开发者可以使用 getCurrentPages() 函数获取当前页面栈<ul><li style="list-style-type: none">不要尝试修改页面栈,会导致路由以及页面状态错误； </li>
<li style="list-style-type: none">不要在 App.onLaunch 的时候调用 getCurrentPages() ，此时 page 还没有生成。</li>
</ul>
<br/>
<span style="color: #ff0000">自定义数据</span>：dataset: &nbsp;data- 开头，多个单词由连字符 - 连接。这种写法中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。如：<ul><li style="list-style-type: none"><ul><li style="list-style-type: none">data-element-type ，最终会呈现为 event.currentTarget.dataset.elementType ；</li>
<li style="list-style-type: none">data-elementType ，最终会呈现为 event.currentTarget.dataset.elementtype 。</li>
<li style="list-style-type: none"></li>
</ul>
</li>
</ul>
<span style="color: #ff0000">mark: </span>在基础库版本 2.7.1 以上，可以<span style="color: #ff0000">使用 mark 来识别具体触发事件的 target 节点</span>。此外， mark 还可以用于承载一些自定义数据（类似于 dataset ）。<ul><li style="list-style-type: none"><ul><li style="list-style-type: none">当事件触发时，事件冒泡路径上所有的 mark 会被合并，并返回给事件回调函数。（即使事件不是冒泡事件，也会 mark 。）</li>
</ul>
</li>
</ul>
<br/>
<span style="color: #ff0000">detail:</span>&nbsp;自定义事件所携带的数据<hr/><span style="color: #ff0000">屏幕旋转事件（框架：视图层：响应显示区域的变化）</span><ul><li style="list-style-type: none">在 js 中读取页面的<span style="color: #ff0000">显示区域尺寸</span>，可以使用 <span style="color: #ff0000">selectorQuery</span>.<span style="color: #ff0000">selectViewport</span>&nbsp;。</li>
</ul>
<ul><li style="list-style-type: none">页面尺寸发生改变的事件，可以使用页面的 <span style="color: #ff0000">onResize</span>&nbsp;来监听。对于自定义组件，可以使用 <span style="color: #ff0000">resize</span>&nbsp;生命周期来监听。回调函数中将返回显示区域的尺寸信息。（从基础库版本 2.4.0 开始支持。）</li>
</ul>
<ul><li style="list-style-type: none">此外，还可以使用 wx.<span style="color: #ff0000">onWindowResize</span>&nbsp;来监听（<span style="color: #ff0000">但这不是推荐的方式</span>）。</li>
</ul>
<hr/><span style="color: #ff0000">wxs:</span>&#09;事件系统 ：wxs 响应事件：基础库 2.4.4 开始支持，低版本需做兼容处理。目前只能响应内置组件的事件，不支持自定义组件事件. <ul><li style="list-style-type: none"><ul><span style="color: #ff0000"><li style="list-style-type: none">change:prop（属性前面带change:前缀）是在 prop 属性被设置的时候触发 WXS 函数，值必须用{{}}括起来。</li>
</span><li style="list-style-type: none"><span style="color: #ff0000">逻辑层和渲染层的通信</span>频繁时，使用。</li>
<li style="list-style-type: none">注意：WXS函数必须用{{}}括起来。当 prop 的值被设置 WXS 函数就会触发，而不只是值发生改变，所以在页面初始化的时候会调用一次WxsPropObserver的函数。</li>
<li style="list-style-type: none"></li>
</ul>
</li>
</ul>
<span style="color: #ff0000">数据绑定 数据双向绑定</span>：(框架：视图层) &nbsp; &nbsp;&lt;input model:value="{{customValue}}" /&gt;<hr/><span style="color: #ff0000">与组件之间通信：<br/>
</span>-----------------------<br/>
<span style="color: #ff0000">//comp.wxml:<br/>
</span><br/>
&lt;input model:<span style="color: #ff0000">value</span>="{{<span style="color: #ff0000">customValue</span>}}" /&gt;<br/>
-----------------------<br/>
<span style="color: #ff0000">// index/comp.js</span><br/>
Component({<br/>
&nbsp; properties: {<br/>
&nbsp; &nbsp; <span style="color: #ff0000">customValue</span>: String<br/>
&nbsp; },<br/>
})<br/>
-----------------------<br/>
<span style="color: #ff0000">index.wxml:</span><br/>
&nbsp;&lt;comp model:<span style="color: #ff0000">customValue</span>="{{ <span style="color: #ff0000">value</span>&nbsp;}}" /&gt; &nbsp;<br/>
-----------------------<br/>
<span style="color: #ff0000">index.js:</span><br/>
<br/>
const app = getApp()<br/>
<br/>
Page({<br/>
&nbsp; data: {<br/>
&nbsp; &nbsp; <span style="color: #ff0000">value</span>: '这是一个例子数据 ',<br/>
&nbsp; &nbsp; currentSwiperItem: 0,<br/>
&nbsp; &nbsp; scrollTop: 40,<br/>
&nbsp; },<br/>
})<br/>
-----------------------<br/>
imrdr 总结： 在组件中定义一个属性，在index.wxml 中使用这个组件时，使用同名的属性获取这个值。<hr/>comp:<br/>
在 comp.wxml 中<span style="color: #ff0000">&nbsp;bindtap='a' </span>绑定一个“方法a";<br/>
在 comp.js 中定义 "方法a": <br/>
&#09;this.triggerEvent('A', myEventDetail, myEventOption)<br/>
&#09;//定义了 方法a 触发的 事件A<br/>
<br/>
在 index.wxml 中使用 "bind:A = b" 来绑定 "事件A"; "事件A" 的方法是 “方法b”<br/>
在 index.js 中定义 “方法b”：<br/>
&#09;b: function(e):{<br/>
&#09;&#09;//方法b 的目的<br/>
&#09;&#09;console.log(e)<br/>
&#09;}<br/>
<span style="color: #ff0000">总结：在 comp 中用 triggerEvent 定义了一个事件A；在 index.wxml 中使用 bind:A 来使用。</span><hr/><span style="color: #ff0000">自定义组件 </span>： 监听数据 ：observers<br/>
<br/>
<span style="color: #ff0000">基础组件</span>：（视图层：基础组件）注意：<span style="color: #ff0000">所有组件与属性都是小写，以连字符-连接</span><br/>
<br/>
<span style="color: #ff0000">组件是否显示</span>： &#09;<b><span style="color: #ff0000">hidden&#09;</span></b><span style="color: #ff0000">Boolean&#09;&#09;组件是否显示&#09;&#09;所有组件默认显示</span><br/>
<br/>
<span style="color: #ff0000">所有组</span>件有拥有的公共属性：（基础组件：）<br/>
<br/>
<span style="color: #ff0000">自定义组件的<b>自定义属性</b></span>：<br/>
<b><span style="color: #ff0000">自定义属性</span></b><ul><strike><li style="list-style-type: none">在component.js 中定义的属性，可以通过 methods 中的 this.detail.yourDiyProp</li>
<li style="list-style-type: none">自定义的方法，同样。</li>
</strike><li style="list-style-type: none">e.target.dataset.<span style="color: #ff0000">name</span>&nbsp; //data-<span style="color: #ff0000">name</span></li>
<li style="list-style-type: none">console.log(e.currentTarget.dataset.id)</li>
<li style="list-style-type: none">获取自定义组件的自定义属性：this.data.属性名</li>
<li style="list-style-type: none"></li>
</ul>
triggerEvent：imrdr mark<hr/><span style="color: #ff0000">获取界面上的节点信息:</span><ul><li style="list-style-type: none">最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。const query = wx.createSelectorQuery()</li>
<li style="list-style-type: none">在自定义组件或包含自定义组件的页面中，推荐使用 this.<span style="color: #ff0000">createSelectorQuery</span>&nbsp;来代替 wx.createSelectorQuery ，这样可以确保在正确的范围内选择节点。</li>
<li style="list-style-type: none"><span style="color: #ff0000">节点布局相交状态</span>&nbsp;API :</li>
<li style="list-style-type: none">用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见</li>
</ul>
<hr/><span style="color: #ff0000">在手机上启用屏幕旋转支持：</span><br/>
<ul><li style="list-style-type: none">从小程序基础库版本 2.4.0 开始，小程序在手机上支持屏幕旋转。使小程序中的页面支持屏幕旋转的方法是：</li>
<li style="list-style-type: none">在 app.<span style="color: #ff0000">json</span>&nbsp;的 <span style="color: #ff0000">window</span>&nbsp;段中设置 "<span style="color: #ff0000">pageOrientation</span>": "auto" ，</li>
<li style="list-style-type: none">或在页面 <span style="color: #ff0000">json</span>&nbsp;文件中配置 "pageOrientation": "auto" 。</li>
<li style="list-style-type: none">从小程序基础库版本 2.5.0 开始， pageOrientation 还可以被设置为 <span style="color: #ff0000">landscape</span>&nbsp;，表示固定为<span style="color: #ff0000">横屏显示</span>。</li>
</ul>
<hr/><span style="color: #ff0000">动画： </span><ul><li style="list-style-type: none"><span style="color: #ff0000">界面动画的常见方式：</span>在小程序中，通常可以使用<span style="color: #ff0000">&nbsp;CSS 渐变 和 CSS 动画</span>&nbsp;来创建<span style="color: #ff0000">简易的界面动画</span>。</li>
<li style="list-style-type: none">&lt;moveable-view&gt;</li>
<li style="list-style-type: none">滚动驱动的动画</li>
<li style="list-style-type: none">连续使用 setData 来改变界面的方法也可以达到动画的效果。这样可以任意地改变界面，但通常会产生较大的延迟或卡顿，甚至导致小程序僵死。此时可以通过<span style="color: #ff0000">将页面的 setData 改为 自定义组件 中的 setData 来提升性能</span></li>
</ul>
<hr/><span style="color: #ff0000">文本换行</span>：\n<br/>
<br/>
<span style="color: #ff0000">获取手机宽度</span>： left: wx.getSystemInfoSync().windowWidth - 17<br/>
<br/>
监听资源： <span style="color: #ff0000">使用 wx.onMemoryWarning 监听内存告警事件</span>。<br/>
<br/>
<span style="color: #ff0000">小程序可能被销毁之前：</span>页面回调函数 <span style="color: #ff0000">onSaveExitState</span>&nbsp;会被调用。如果想保留页面中的状态，可以在这个回调函数中“保存”一些数据，下次启动时可以通过 <span style="color: #ff0000">exitState</span>&nbsp;获得这些已保存数据。<br/>
<br/>
小程序更新：<span style="color: #ff0000">如果需要马上应用最新版本，可以使用 wx.getUpdateManager API 进行处理。</span><hr/><span style="color: #ff0000">自定义组件</span>： component 字段设为 true。<ul><li style="list-style-type: none">组件的属性值和内部数据将被用于组件 wxml 的渲染，其中，<span style="color: #ff0000">属性值是可由组件外部传入的。在组件使用时指定。</span></li>
<li style="list-style-type: none">开发者工具 1.02.1810190 及以上版本支持在 app.json 中声明 usingComponents 字段，在此处声明的自定义组件视为<span style="color: #ff0000">全局自定义组件</span>，<span style="color: #ff0000">在小程序内的页面或自定义组件中可以直接使用而无需再声明。</span></li>
<span style="color: #ff0000"><li style="list-style-type: none"></li>
</span><li style="list-style-type: none"><span style="color: #ff0000">WXML 节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。</span></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"><span style="color: #ff0000">自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。</span></li>
</ul>
<ul><li style="list-style-type: none">注意，<span style="color: #ff0000">是否在页面文件中使用 usingComponents 会使得页面的 this 对象的原型稍有差异，包括：</span></li>
</ul>
<ul><li style="list-style-type: none">使用 usingComponents 页面的原型与不使用时不一致，即 Object.getPrototypeOf(this) 结果不同。</li>
<li style="list-style-type: none">使用 usingComponents 时会多一些方法，如 selectComponent 。</li>
<li style="list-style-type: none">出于性能考虑，使用 usingComponents 时， setData 内容不会被直接<span style="color: #ff0000">深复制</span>，即 this.setData({ field: obj }) 后 this.data.field === obj 。（<span style="color: #ff0000">深复制会在这个值被组件间传递时发生</span>。）</li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none">需要使用<span style="color: #ff0000">多slot时</span>，可以在组件js中声明启用。</li>
<li style="list-style-type: none">Component({</li>
<li style="list-style-type: none">&nbsp; options: {</li>
<li style="list-style-type: none">&nbsp;<span style="color: #ff0000">&nbsp; &nbsp;multipleSlots: true // 在组件定义时的选项中启用多slot支持</span></li>
<li style="list-style-type: none">&nbsp; }</li>
<li style="list-style-type: none">})</li>
<li style="list-style-type: none"></li>
</ul>
<span style="color: #ff0000">内部方法： &#09;建议以下划线开头</span>;<br/>
<span style="color: #ff0000">页面参数</span>：&#09;<span style="color: #ff0000">组件的属性可以用于接收页面的参数，如访问页面 /pages/index/index?paramA=123&amp;paramB=xyz ，</span><span style="color: #ff0000"><ul><li style="list-style-type: none"><ul><li style="list-style-type: none"><ul><li style="list-style-type: none">如果声明有属性 paramA 或 paramB ，则它们会被赋值为 123 或 xyz 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</span><span style="color: #ff0000">触发事件：</span><ul><li style="list-style-type: none">自定义组件触发事件时，需要使用 <span style="color: #ff0000">triggerEvent</span>&nbsp;方法，指定事件名、detail对象和事件选项： &nbsp;this.triggerEvent('myevent', myEventDetail, myEventOption)</li>
<li style="list-style-type: none"></li>
</ul>
<span style="color: #ff0000">组件的生命周期</span>，指的是组件自身的一些函数，<span style="color: #ff0000">这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。</span><ul><li style="list-style-type: none"><ul><li style="list-style-type: none">其中，最重要的生命周期是 created attached detached ，包含一个组件实例生命流程的最主要时间点。</li>
<li style="list-style-type: none"></li>
</ul>
</li>
</ul>
<span style="color: #ff0000">使自定义组件支持 export 定义段</span>。这个定义段可以用于指定组件被 <span style="color: #ff0000">selectComponent</span>&nbsp;调用时的返回值。<ul><li style="list-style-type: none"><ul><li style="list-style-type: none">Component({</li>
</ul>
</li>
</ul>
&nbsp; &#09;&#09;&#09;&#09;behaviors: ['wx://component-export']<ul><li style="list-style-type: none"><ul><li style="list-style-type: none"><ul><li style="list-style-type: none">})</li>
</ul>
</li>
</ul>
</li>
</ul>
组件间关系:&#09; <span style="color: #ff0000">在组件定义时加入 relations 定义段</span>. <span style="color: #ff0000">必须在两个组件定义中都加入relations定义，否则不会生效<br/>
</span><span style="color: #ff0000">祖先节点</span>: &#09;&#09; &nbsp;type: '<span style="color: #ff0000">ancestor</span>', // 关联的目标节点应为祖先节点。<br/>
<br/>
获得nodes数组: &nbsp;使用<span style="color: #ff0000">getRelationNodes</span>可以获得nodes数组，包含所有已关联的custom-li，且是有序的. <br/>
<hr/>组件间的基本通信方式： <ul><li style="list-style-type: none"><span style="color: #ff0000">WXML 数据绑定</span>：用于父组件向子组件的指定属性设置数据，<span style="color: #ff0000">仅能设置 JSON 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）</span>。</li>
<li style="list-style-type: none"><span style="color: #ff0000">事件</span>：用于子组件向父组件传递数据，可以传递任意数据。</li>
<li style="list-style-type: none">如果以上两种方式不足以满足需要，<span style="color: #ff0000">父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。</span></li>
</ul>
<span style="color: #ff0000"><br/>
</span>数据监听器： <span style="color: #ff0000">监听和响应任何属性和数据字段的变化。从小程序基础库版本 2.6.1 开始支持。</span><ul><li style="list-style-type: none"><ul><li style="list-style-type: none"><span style="color: #ff0000">数据监听器 </span>observers <span style="color: #ff0000">和属性的 observer 相比</span>，数据监听器更强大且通常具有更好的性能。</li>
</ul>
</li>
</ul>
<hr/><span style="color: #ff0000">纯数据字段： &nbsp;指定“纯数据字段”的方法</span>是在 <span style="color: #ff0000">Component</span>&nbsp;构造器的 <span style="color: #ff0000">options</span>&nbsp;定义段中指定 <span style="color: #ff0000">pureDataPattern</span>&nbsp;为一个正则表达式，<ul><li style="list-style-type: none"><ul><span style="color: #ff0000"><li style="list-style-type: none">字段名符合这个正则表达式的字段将成为纯数据字段。</li>
</span><li style="list-style-type: none">Component({</li>
<li style="list-style-type: none">&nbsp; options: {</li>
<li style="list-style-type: none">&nbsp; <span style="color: #ff0000">&nbsp; pureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段</span></li>
<li style="list-style-type: none">&nbsp; }</li>
<li style="list-style-type: none">})</li>
<li style="list-style-type: none">另外：也可以在 <span style="color: #ff0000">json 文件中配置</span>。</li>
<li style="list-style-type: none"></li>
</ul>
</li>
</ul>
<hr/><span style="color: #ff0000">存储限制</span>： 同一个微信用户，同一个小程序 storage 上限为 <span style="color: #ff0000">10MB</span><br/>
<hr/><br/>
小程序端在获取集合数据时服务器一次默认并且最多返回<span style="color: #ff0000">&nbsp;20 条记录</span>，云函数端这个数字则是 <span style="color: #ff0000">100</span>。开发者可以通过 limit 方法指定需要获取的记录数量，但小程序端不能超过 20 条，云函数端不能超过 100 条。<br/>
<br/>
<span style="color: #ff0000">doc 方法</span>：假设我们有一个<span style="color: #ff0000">待办事项的 ID 为 todo-identifiant-aleatoire，那么我们可以通过 doc 方法获取它的引用：</span><ul><li style="list-style-type: none"><ul><li style="list-style-type: none">const todo = db.collection('todos').<span style="color: #ff0000">doc</span>('todo-identifiant-aleatoire')</li>
<li style="list-style-type: none"></li>
</ul>
</li>
</ul>
云开发： 上传成功后会获得<span style="color: #ff0000">文件唯一标识符，即文件 ID，后续操作都基于文件 ID 而不是 URL。</span><br/>
未指定环境：右键：更多设置：环境； <br/>
<br/>
在小程序中调用之前，右键：上传并部署所有文件。之后，才可以调用。<br/>
<span style="color: #ff0000">不使用本地调试时的调试流程:（“本地修改代码 -&gt; 上传部署云函数 -&gt; 调用"）</span><hr/>云函数 hello world:<br/>
// 云函数入口文件<br/>
const cloud = require('wx-server-sdk')<br/>
<br/>
cloud.init()<br/>
<br/>
// 云函数入口函数<br/>
exports.main = async (event, context) =&gt; { &nbsp;<br/>
&nbsp; return {<br/>
&nbsp; &nbsp; sum: event.a + event.b<br/>
&nbsp; }<br/>
}<hr/><span style="color: #ff0000">如果需要默认 UTC+8，可以配置<b>函数的环境变量</b>，设置 TZ 为 asia/shanghai。</span><br/>
<hr/>`` 的用法：<br/>
const code = `// 云函数入口函数<br/>
exports.main = (event, context) =&gt; {<br/>
&nbsp; console.log(event)<br/>
&nbsp; console.log(context)<br/>
&nbsp; return {<br/>
&nbsp; &nbsp; sum: event.a + event.b<br/>
&nbsp; }<br/>
}`<hr/><br/>
<br/>
<br/>
<br/>
<br/>
<ul><li style="list-style-type: none"></li>
</ul>
<ul><li style="list-style-type: none"></li>
</ul>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<ul><li style="list-style-type: none"><ul><li style="list-style-type: none"><ul><li style="list-style-type: none"></li>
</ul>
</li>
</ul>
</li>
</ul>
</body></html>