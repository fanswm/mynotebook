<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>数据驱动</title>
</head><body>在开发UI界面过程中，<span style="color: #ff0000">程序需要维护很多变量状态，同时要操作对应的UI元素</span>。随着界面越来越复杂，我们需要维护很多<span style="color: #ff0000">变量状态</span>，同时要处理很多界面上的<span style="color: #ff0000">交互事件</span>，整个程序变得越来越复杂。<br/>
<br/>
<span style="color: #ff0000">通常界面视图和变量状态是相关联的</span>，如果有某种“方法”可以<span style="color: #ff0000">让状态和视图绑定在一起</span>（状态变更时，视图也能自动变更），那我们就可以省去手动修改视图的工作。<br/>
<span style="color: #ff0000">这个方法就是“数据驱动”，</span>下边我们来介绍一下小程序的数据驱动基本原理。<br/>
<br/>
WXML结构实际上等价于一棵Dom树，通过一个JS对象也可以来表达Dom树的结构，如图3-2所示。<br/>
<img src="screenshot.png" /><br/>
<br/>
<br/>
图3-2 WXML结构和JS对象均可以表示一棵Dom树<br/>
<br/>
WXML可以先转成JS对象，然后再渲染出真正的Dom树，回到“Hello World”那个例子，我们可以看到转换的过程如图3-3所示。<br/>
<br/>
<img src="screenshot 2.png" /><br/>
<br/>
图3-3 <span style="color: #ff0000">WXML结构转JS对象，再转Dom树</span><br/>
<br/>
<span style="color: #ff0000">通过setData把msg数据从“Hello World”变成“Goodbye”，产生的JS对象对应的节点就会发生变化，此时可以对比前后两个JS对象得到变化的部分，然后把这个差异应用到原来的Dom树上，从而达到更新UI的目的，这就是“数据驱动”的原理</span>，如图3-4所示。<br/>
<img src="screenshot 3.png" /><br/>
<br/>
<br/>
图3-4 状态更新的时候，通过对比前后JS对象变化，进而改变视图层的Dom树</body></html>