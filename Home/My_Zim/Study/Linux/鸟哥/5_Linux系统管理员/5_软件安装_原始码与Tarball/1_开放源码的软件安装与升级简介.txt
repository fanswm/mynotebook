Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2017-11-22T13:41:47+08:00

====== 1 开放源码的软件安装与升级简介 ======
Created Wednesday 22 November 2017

1. 开放源码的软件安装与升级简介
　　1.1 什么是开放源码、编译器与可运行档
　　1.2 什么是函式库
　　1.3 什么是 make 与 configure
　　1.4 什么是 Tarball 的软件
　　1.5 如何安装与升级软件
 大标题的图示开放源码的软件安装与升级简介
如果鸟哥想要在我的 Linux 服务器上面跑网页服务器 (WWW server) 这项服务，那么我应该要做些什么事呢？当然就一定需要『安装网页服务器的软件』罗！如果鸟哥的服务器上面没有这个软件的话，那当然也就无法激活 WWW 的服务啦！所以啦，想要在你的 Linux 上面进行一些有的没的功能，学会『如何安装软件』是很重要的一个课题！

咦！安装软件有什么难的？在 W 牌的操作系统上面安装软件时，不是只要一直给他按 『下一步』就可以安装妥当了吗？话是这样说没错啦，不过，也由於如此，所以在 Windows 系统上面的软件都是一模一样的，也就是说，你『无法修改该软件的原始程序码』，因此， 万一你想要添加或者减少该软件的某些功能时，大概只能求助於当初发行该软件的厂商了！(这就是所谓的商机吗？)

或许你会说：『唉呦！我不过是一般人，不会用到多余的功能，所以不太可能会更动到程序码的部分吧？』 如果你这么想的话，很抱歉～是有问题的！怎么说呢？像目前网络上面的病毒、黑客软件、臭虫程序等等， 都可能对你的主机上面的某些软件造成影响，导致主机的死机或者是其他数据损毁等等的伤害。 如果你可以藉由安全资讯单位所提供的修订方式进行修改， 那么你将可以很快速的自行修补好该软件的漏洞，而不必一定要等到软件开发商提供修补的程序包哩！要知道，提早补洞是很重要的一件事。

Tips:
并不是软件开发商故意要搞出一个有问题的软件，而是某些程序码当初设计时可能没有考量周全， 或者是程序码与操作系统的权限配置并不相同，所导致的一些漏洞。当然，也有可能是 cracker 透过某些攻击程序测试到程序的不周全所致。 无论如何，只要有网络存在的一天，可以想像的到，程序的漏洞永远补不完！但能补多少就补多少吧！	鸟哥的图示
这样说可以了解 Linux 的优点了吗？没错！因为 Linux 上面的软件几乎都是经过 GPL 的授权，所以每个软件几乎均提供原始程序码， 并且你可以自行修改该程序码，以符合你个人的需求呢！很棒吧！这就是开放源码的优点罗！不过，到底什么是开放源码？ 这些程序码是什么咚咚？又 Linux 上面可以运行的相关软件文件与开放源码之间是如何转换的？不同版本的 Linux 之间能不能使用同一个运行档？或者是该运行档需要由原始程序码的部分重新进行转换？ 这些都是需要厘清观念的。底下我们先就原始程序码与可运行档来进行说明。


小标题的图示什么是开放源码、编译器与可运行档
在讨论程序码是什么之前，我们先来谈论一下什么是可运行档？我们说过，在 Linux 系统上面，一个文件能不能被运行看的是有没有可运行的那个权限 (具有 x permission)，不过，Linux 系统上真正认识的可运行档其实是二进位文件 ( binary program)，例如 /usr/bin/passwd, /bin/touch 这些个文件即为二进位程序码。

或许你会说 shell scripts 不是也可以运行吗？其实 shell scripts 只是利用 shell (例如 bash) 这支程序的功能进行一些判断式，而最终运行的除了 bash 提供的功能外，仍是呼叫一些已经编译好的二进位程序来运行的呢！ 当然啦， bash 本身也是一支二进位程序啊！那么我怎么知道一个文件是否为 binary 呢？还记得我们在第七章里面提到的 file 这个命令的功能吗？对啦！用他就是了！我们现在来测试一下：

# 先以系统的文件测试看看：
[root@www ~]# file /bin/bash
/bin/bash: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/
Linux 2.6.9, dynamically linked (uses shared libs), for GNU/Linux 2.6.9, stripped

# 如果是系统提供的 /etc/init.d/syslog 呢？
[root@www ~]# file /etc/init.d/syslog
/etc/init.d/syslog: Bourne-Again shell script text executable
看到了吧！如果是 binary 而且是可以运行的时候，他就会显示运行档类别 (ELF 32-bit LSB executable)， 同时会说明是否使用动态函式库 (shared libs)，而如果是一般的 script ，那他就会显示出 text executables 之类的字样！

Tips:
事实上，syslog 的数据显示出 Bourne-Again ... 那一行，是因为你的 scripts 上面第一行有宣告 #!/bin/bash 的缘故，如果你将 script 的第一行拿掉，那么不管 /etc/init.d/syslog 的权限为何，他其实显示的是 ASCII 文字档的资讯喔！	鸟哥的图示
既然 Linux 操作系统真正认识的其实是 binary program，那么我们是如何做出这样的一支 binary 的程序呢？首先，我们必须要写程序，用什么东西写程序？就是一般的文书处理器啊！鸟哥都喜欢使用 vim 来进行程序的撰写，写完的程序就是所谓的原始程序码罗！ 这个程序码文件其实就是一般的纯文字档。 在完成这个原始码文件的编写之后，再来就是要将这个文件『编译』成为操作系统看的懂得 binary program 罗！而要编译自然就需要『编译器』来动作， 经过编译器的编译与连结之后，就会产生一支可以运行的 binary program 罗。

举个例子来说，在 Linux 上面最标准的程序语言为 C ，所以我使用 C 的语法进行原始程序码的书写，写完之后，以 Linux 上标准的 C 语言编译器 gcc 这支程序来编译，就可以制作一支可以运行的 binary program 罗。整个的流程有点像这样：

 利用 gcc 编译器进行程序的编译流程示意图
图 1.1.1、利用 gcc 编译器进行程序的编译流程示意图"
事实上，在编译的过程当中还会产生所谓的目标档 (Object file)，这些文件是以 *.o 的扩展名样式存在的！至於 C 语言的原始码文件通常以 *.c 作为扩展名。此外，有的时候，我们会在程序当中『引用、呼叫』 其他的外部副程序，或者是利用其他软件提供的『函数功能』，这个时候，我们就必须要在编译的过程当中， 将该函式库给他加进去，如此一来，编译器就可以将所有的程序码与函式库作一个连结 (Link) 以产生正确的运行档罗。

总之，我们可以这么说：

开放源码：就是程序码，写给人类看的程序语言，但机器并不认识，所以无法运行；
编译器：将程序码转译成为机器看的懂得语言，就类似翻译者的角色；
可运行档：经过编译器变成二进位程序后，机器看的懂所以可以运行的文件。
小标题的图示什么是函式库
在前一小节的图1.1.1示意图中，在编译的过程里面有提到函式库这东西。 什么是函式库呢？先举个例子来说：我们的 Linux 系统上通常已经提供一个可以进行身份验证的模块， 就是在第十四章提到的 PAM 模块。这个 PAM 提供的功能可以让很多的程序在被运行的时候，除了可以验证使用者登陆的资讯外， 还可以将身份确认的数据记录在登录文件里面，以方便系统管理员的追踪！

既然有这么好用的功能，那如果我要编写具有身份认证功能的程序时，直接引用该 PAM 的功能就好啦，如此一来，我就不需要重新设计认证机制罗！也就是说，只要在我写的程序码里面，配置去呼叫 PAM 的函式功能，我的程序就可以利用 Linux 原本就有的身份认证的程序咯！除此之外，其实我们的 Linux 核心也提供了相当多的函式库来给硬件开发者利用喔。

函式库又分为动态与静态函式库，这两个咚咚的分别我们在后面的小节再加以说明。 这里我们以一个简单的流程图，来示意一支有呼叫外部函式库的程序的运行情况。

 程序运行时引用外部动态函式库的示意图
图 1.2.1、程序运行时引用外部动态函式库的示意图
很简单的示意图啊！^_^！而如果要在程序里面加入引用的函式库，就需要如图 1.1.1 所示， 亦即在编译的过程当中，就需要加入函式库的相关配置罗。 事实上， Linux 的核心提供很多的核心相关函式库与外部参数， 这些核心功能在设计硬件的驱动程序的时候是相当有用的资讯，这些核心相关资讯大多放置在 /usr/include, /lib, /usr/lib 里面哩！我们在本章的后续小节再来探讨。反正我们可以简单的这么想：

函式库：就类似副程序的角色，可以被呼叫来运行的一段功能函数。
小标题的图示什么是 make 与 configure
事实上，使用类似 gcc 的编译器来进行编译的过程并不简单，因为一套软件并不会仅有一支程序， 而是有一堆程序码文件。所以除了每个主程序与副程序均需要写上一笔编译过程的命令外，还需要写上最终的连结程序。 程序码小的时候还好，如果是类似 WWW 服务器软件 (例如 Apache) ，或者是类似核心的原始码，动则数百 MBytes 的数据量，编译命令会写到疯掉～这个时候，我们就可以使用 make 这个命令的相关功能来进行编译过程的命令简化了！

当运行 make 时，make 会在当时的目录下搜寻 Makefile (or makefile) 这个文字档，而 Makefile 里面则记录了原始码如何编译的详细资讯！ make 会自动的判别原始码是否经过变动了，而自动升级运行档，是软件工程师相当好用的一个辅助工具呢！

咦！make 是一支程序，会去找 Makefile ，那 Makefile 怎么写？ 通常软件开发商都会写一支侦测程序来侦测使用者的作业环境， 以及该作业环境是否有软件开发商所需要的其他功能，该侦测程序侦测完毕后，就会主动的创建这个 Makefile 的守则文件啦！通常这支侦测程序的档名为 configure 或者是 config 。

咦！那为什么要侦测作业环境呢？在第一章当中， 不是曾经提过其实每个 Linux distribution 都使用同样的核心吗？但你得要注意， 不同版本的核心所使用的系统呼叫可能不相同，而且每个软件所需要的相依的函式库也不相同， 同时，软件开发商不会仅针对 Linux 开发，而是会针对整个 Unix-Like 做开发啊！ 所以他也必须要侦测该操作系统平台有没有提供合适的编译器才行！所以当然要侦测环境啊！ 一般来说，侦测程序会侦测的数据大约有底下这些：

是否有适合的编译器可以编译本软件的程序码；
是否已经存在本软件所需要的函式库，或其他需要的相依软件；
操作系统平台是否适合本软件，包括 Linux 的核心版本；
核心的表头定义档 (header include) 是否存在 (驱动程序必须要的侦测)。
至於 make 与 configure 运行流程的相关性，我们可以使用底下的图示来示意一下啊！ 下图中，你要进行的任务其实只有两个，一个是运行 configure 来创建 Makefile ， 这个步骤一定要成功！成功之后再以 make 来呼叫所需要的数据来编译即可！非常简单！

透过 configure 与 make 进行编译示意图
图 1.3.1、透过 configure 与 make 进行编译示意图
由於不同的 Linux distribution 的函式库文件所放置的路径，或者是函式库的档名订定， 或者是默认安装的编译器，以及核心的版本都不相同，因此理论上，你无法在 CentOS 5.x 上面编译出 binary program 后，还将他拿到 SuSE 上面运行，这个动作通常是不可能成功的！ 因为呼叫的目标函式库位置可能不同 (参考图1.2.1) ， 核心版本更不可能相同！所以能够运行的情况是微乎其微！所以同一套软件要在不同的平台上面运行时， 必须要重复编译！所以才需要原始码嘛！了解乎！

详细的 make 用法与 Makefile 守则，在后续的小节里面再探讨罗！

小标题的图示什么是 Tarball 的软件
从前面几个小节的说明来看，我们知道所谓的原始程序码，其实就是一些写满了程序码的纯文字文件。 那我们在第九章压缩命令的介绍当中， 也了解了纯文字档在网络上其实是很浪费频宽的一种文件格式！ 所以啦，如果能够将这些原始码透过文件的打包与压缩技术来将文件的数量与容量减小， 不但让使用者容易下载，软件开发商的网站频宽也能够节省很多很多啊！这就是 Tarball 文件的由来罗！

Tips:
想一想，一个核心的原始码文件大约要 300~500 MB 以上，如果每个人都去下载这样的一个核心文件， 呵呵！那么网络频宽不被吃的死翘翘才怪呢！	鸟哥的图示
所谓的 Tarball 文件，其实就是将软件的所有原始码文件先以 tar 打包，然后再以压缩技术来压缩，通常最常见的就是以 gzip 来压缩了。因为利用了 tar 与 gzip 的功能，所以 tarball 文件一般的扩展名就会写成 *.tar.gz 或者是简写为 *.tgz 罗！不过，近来由於 bzip2 的压缩率较佳，所以 Tarball 渐渐的以 bzip2 的压缩技术来取代 gzip 罗！因此档名也会变成 *.tar.bz2 之类的哩。所以说， Tarball 是一个软件包， 你将他解压缩之后，里面的文件通常就会有：

原始程序码文件；
侦测程序文件 (可能是 configure 或 config 等档名)；
本软件的简易说明与安装说明 (INSTALL 或 README)。
其中最重要的是那个 INSTALL 或者是 README 这两个文件，通常你只要能够参考这两个文件， Tarball 软件的安装是很简单的啦！我们在后面的章节会再继续介绍 Tarball 这个玩意儿。

小标题的图示如何安装与升级软件
将原始码作了一个简单的介绍，也知道了系统其实认识的可运行档是 binary program 之后，好了，得要聊一聊，那么怎么安装与升级一个 Tarball 的软件？为什么要安装一个新的软件呢？当然是因为我们的主机上面没有该软件罗！那么， 为何要升级呢？原因可能有底下这些：

需要新的功能，但旧有主机的旧版软件并没有，所以需要升级到新版的软件；
旧版本的软件上面可能有资安上的顾虑，所以需要升级到新版的软件；
旧版的软件运行效能不彰，或者运行的能力不能让管理者满足。
在上面的需求当中，尤其需要注意的是第二点，当一个软件有安全上的顾虑时，千万不要怀疑， 赶紧升级软件吧！否则造成网络危机，那可不是闹著玩的！那么升级的方法有哪些呢？ 基本上升级的方法可以分为两大类，分别是：

直接以原始码透过编译来安装与升级；
直接以编译好的 binary program 来安装与升级。
上面第一点很简单，就是直接以 Tarball 在自己的机器上面进行侦测、编译、 安装与配置等等动作来升级就是了。不过，这样的动作虽然让使用者在安装过程当中具有很高的弹性， 但毕竟是比较麻烦一点，如果 Linux distribution 厂商能够针对自己的作业平台先进行编译等过程，再将编译好的 binary program 释出的话，那由於我的系统与该 Linux distribution 的环境是相同的，所以他所释出的 binary program 就可以在我的机器上面直接安装啦！省略了侦测与编译等等繁杂的过程呢！

这个预先编译好程序的机制存在於很多 distribution 喔，包括有 Red Hat 系统 (含 Fedora/CentOS 系列) 发展的 RPM 软件管理机制与 yum 线上升级模式； Debian 使用的 dpkg 软件管理机制与 APT 线上升级模式等等。

由於 CentOS 系统是依循标准的 Linux distribution，所以可以使用 Tarball 直接进行编译的安装与升级， 当然也可以使用 RPM 相关的机制来进行安装与升级罗！本章节主要针对 Tarball ，至於 RPM 则留待下个章节再来介绍呢！

好了，那么一个软件的 Tarball 是如何安装的呢？基本流程是这样的啦：

将 Tarball 由厂商的网页下载下来；
将 Tarball 解开，产生很多的原始码文件；
开始以 gcc 进行原始码的编译 (会产生目标档 object files)；
然后以 gcc 进行函式库、主、副程序的连结，以形成主要的 binary file；
将上述的 binary file 以及相关的配置档安装至自己的主机上面。
上面第 3, 4 步骤当中，我们可以透过 make 这个命令的功能来简化他， 所以整个步骤其实是很简单的啦！只不过你就得需要至少有 gcc 以及 make 这两个软件在你的 Linux 系统里面才行喔！ 详细的过程以及需要的软件我们在后面的章节继续来介绍的啦！

