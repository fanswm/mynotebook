Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2017-12-11T16:37:10+08:00

====== 1 目录与路径 ======
Created Monday 11 December 2017

目录与路径：
由第六章Linux的文件权限与目录配置中透过FHS了解了Linux的『树状目录』概念之后， 接下来就得要实际的来搞定一些基本的路径问题了！这些目录的问题当中，最重要的莫过於第六章也谈过的『绝对路径』与『相对路径』的意义啦！ 绝对/相对路径的写法并不相同，要特别注意。此外，当你下达命令时，该命令是透过什么功能来取得的？ 这与PATH这个变量有关呢！底下就让我们来谈谈罗！


相对路径与绝对路径：
在开始目录的切换之前，你必须要先了解一下所谓的『路径(PATH)』， 有趣的是：什么是『相对路径』与『绝对路径』？ 虽然前一章已经稍微针对这个议题提过一次，不过，这里不厌其烦的再次的强调一下！

__绝对路径：路径的写法『一定由根目录 / 写起』，例如： /usr/share/doc 这个目录。__
__相对路径：路径的写法『不是由 / 写起』__，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： 『cd ../man』这就是相对路径的写法啦！相对路径意指『相对於目前工作目录的路径！』

相对路径的用途
那么相对路径与绝对路径有什么了不起呀？喝！那可真的是了不起了！假设你写了一个软件， 这个软件共需要三个目录，分别是 etc, bin, man 这三个目录，然而由於不同的人喜欢安装在不同的目录之下， 假设甲安装的目录是 /usr/local/packages/etc, /usr/local/packages/bin 及 /usr/local/packages/man ，不过乙却喜欢安装在 /home/packages/etc, /home/packages/bin, /home/packages/man 这三个目录中，请问如果需要用到绝对路径的话，那么是否很麻烦呢？是的！ 如此一来每个目录下的东西就很难对应的起来！这个时候相对路径的写法就显的特别的重要了！

此外，如果你跟鸟哥一样，喜欢将路径的名字写的很长，好让自己知道那个目录是在干什么的，例如： /cluster/raid/output/taiwan2006/smoke 这个目录，而另一个目录在 /cluster/raid/output/taiwan2006/cctm ，那么我从第一个要到第二个目录去的话，怎么写比较方便？ 当然是『 cd ../cctm 』比较方便罗！对吧！


绝对路径的用途
但是对於档名的正确性来说，『绝对路径的正确度要比较好～』。 一般来说，鸟哥会建议你，如果是在写程序 (shell scripts) 来管理系统的条件下，务必使用绝对路径的写法。 怎么说呢？因为绝对路径的写法虽然比较麻烦，但是可以肯定这个写法绝对不会有问题。 如果使用相对路径在程序当中，则可能由於你运行的工作环境不同，导致一些问题的发生。 这个问题在工作排程(at, cron, 第十六章)当中尤其重要！这个现象我们在十三章、shell script时，会再次的提醒你喔！ ^_^

目录的相关操作：
我们之前稍微提到变换目录的命令是cd，还有哪些可以进行目录操作的命令呢？ 例如创建目录啊、删除目录之类的～还有，得要先知道的，就是有哪些比较特殊的目录呢？ 举例来说，底下这些就是比较特殊的目录，得要用力的记下来才行：

__.         代表此层目录__
__..        代表上一层目录__
__-         代表前一个工作目录__
__~         代表『目前使用者身份』所在的家目录__
__~account  代表 account 这个使用者的家目录(account是个帐号名称)__
需要特别注意的是：在所有目录底下都会存在的两个目录，分别是『.』与『..』 分别代表此层与上一级目录的意思。那么来思考一下底下这个例题：

例题：
请问在Linux底下，根目录下有没有上一级目录(..)存在？
答：
若使用『 ls -al / 』去查询，可以看到根目录下确实存在 . 与 .. 两个目录，再仔细的查阅， 可发现这两个目录的属性与权限完全一致，这代表根目录的上一层(..)与根目录自己(.)是同一个目录。
底下我们就来谈一谈几个常见的处理目录的命令吧：

__cd：变换目录__
__pwd：显示目前的目录__
__mkdir：创建一个新的目录__
__rmdir：删除一个空的目录__

cd (变换目录)
我们知道vbird这个使用者的家目录是/home/vbird/，而root家目录则是/root/，假设我以root身份在 Linux系统中，那么简单的说明一下这几个特殊的目录的意义是：

[root@www ~]# cd [相对路径或绝对路径]
# 最重要的就是目录的绝对路径与相对路径，还有一些特殊目录的符号罗！
[root@www ~]# cd ~vbird
# 代表去到 vbird 这个使用者的家目录，亦即 /home/vbird
[root@www vbird]# cd ~
# 表示回到自己的家目录，亦即是 /root 这个目录
[root@www ~]# cd
# 没有加上任何路径，也还是代表回到自己家目录的意思喔！
[root@www ~]# cd ..
# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；
[root@www /]# cd -
# 表示回到刚刚的那个目录，也就是 /root 罗～
[root@www ~]# cd /var/spool/mail
# 这个就是绝对路径的写法！直接指定要去的完整路径名称！
[root@www mail]# cd ../mqueue
# 这个是相对路径的写法，我们由/var/spool/mail 去到/var/spool/mqueue 就这样写！
cd是Change Directory的缩写，这是用来变换工作目录的命令。注意，目录名称与cd命令之间存在一个空格。 一登陆Linux系统后，root会在root的家目录！那回到上一层目录可以用『 cd .. 』。 利用相对路径的写法必须要确认你目前的路径才能正确的去到想要去的目录。例如上表当中最后一个例子， 你必须要确认你是在/var/spool/mail当中，并且知道在/var/spool当中有个mqueue的目录才行啊～ 这样才能使用cd ../mqueue去到正确的目录说，否则就要直接输入cd /var/spool/mqueue罗～

其实，我们的提示字节，亦即那个 [root@www ~]# 当中，就已经有指出目前的目录了， 刚登陆时会到自己的家目录，而家目录还有一个代码，那就是『 ~ 』符号！ 例如上面的例子可以发现，使用『 cd ~ 』可以回到个人的家目录里头去呢！ 另外，针对 cd 的使用方法，如果仅输入 cd 时，代表的就是『 cd ~ 』的意思喔～ 亦即是会回到自己的家目录啦！而那个『 cd - 』比较难以理解，请自行多做几次练习， 就会比较明白了。

Tips:
还是要一再地提醒，我们的 Linux 的默认命令列模式 (bash shell) 具有文件补齐功能， 你要常常利用 [tab] 按键来达成你的目录完整性啊！这可是个好习惯啊～ 可以避免你按错键盘输入错字说～ ^_^	鸟哥的图示
pwd (显示目前所在的目录)
[root@www ~]# pwd [-P]
选项与参数：
-P  ：显示出确实的路径，而非使用连结 (link) 路径。

范例：单纯显示出目前的工作目录：
[root@www ~]# pwd
/root   <== 显示出目录啦～

范例：显示出实际的工作目录，而非连结档本身的目录名而已
[root@www ~]# cd /var/mail   <==注意，/var/mail是一个连结档
[root@www mail]# pwd
/var/mail         <==列出目前的工作目录
[root@www mail]# pwd -P
/var/spool/mail   <==怎么回事？有没有加 -P 差很多～
[root@www mail]# ls -ld /var/mail
lrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -> spool/mail
# 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail 
# 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！
pwd是Print Working Directory的缩写，也就是显示目前所在目录的命令， 例如在上个表格最后的目录是/var/mail这个目录，但是提示字节仅显示mail， 如果你想要知道目前所在的目录，可以输入pwd即可。此外，由於很多的套件所使用的目录名称都相同，例如 /usr/local/etc还有/etc，但是通常Linux仅列出最后面那一个目录而已，这个时候你就可以使用pwd 来知道你的所在目录罗！免得搞错目录，结果...

其实有趣的是那个 -P 的选项啦！他可以让我们取得正确的目录名称，而不是以连结档的路径来显示的。 如果你使用的是CentOS 5.x的话，刚刚好/var/mail是/var/spool/mail的连结档， 所以，透过到/var/mail下达pwd -P就能够知道这个选项的意义罗～ ^_^


mkdir (创建新目录)
[root@www ~]# mkdir [-mp] 目录名称
选项与参数：
-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～
-p ：帮助你直接将所需要的目录(包含上一级目录)递回创建起来！

范例：请到/tmp底下尝试创建数个新目录看看：
[root@www ~]# cd /tmp
[root@www tmp]# mkdir test    <==创建一名为 test 的新目录
[root@www tmp]# mkdir test1/test2/test3/test4
mkdir: cannot create directory `test1/test2/test3/test4': 
No such file or directory       <== 没办法直接创建此目录啊！
[root@www tmp]# mkdir -p test1/test2/test3/test4
# 加了这个 -p 的选项，可以自行帮你创建多层目录！

范例：创建权限为rwx--x--x的目录
[root@www tmp]# mkdir -m 711 test2
[root@www tmp]# ls -l
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
# 仔细看上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。
# 那么你的默认属性为何？这要透过底下介绍的 umask 才能了解喔！ ^_^
如果想要创建新的目录的话，那么就使用mkdir (make directory)吧！ 不过，在默认的情况下， 你所需要的目录得一层一层的创建才行！例如：假如你要创建一个目录为 /home/bird/testing/test1，那么首先必须要有 /home 然后 /home/bird ，再来 /home/bird/testing 都必须要存在，才可以创建 /home/bird/testing/test1 这个目录！假如没有 /home/bird/testing 时，就没有办法创建 test1 的目录罗！

不过，现在有个更简单有效的方法啦！那就是加上 -p 这个选项喔！你可以直接下达：『 mkdir -p /home/bird/testing/test1 』 则系统会自动的帮你将 /home, /home/bird, /home/bird/testing 依序的创建起目录！并且， 如果该目录本来就已经存在时，系统也不会显示错误信息喔！挺快乐的吧！ ^_^。 不过鸟哥不建议常用-p这个选项，因为担心如果你打错字，那么目录名称就会变的乱七八糟的！

另外，有个地方你必须要先有概念，那就是『默认权限』的地方。我们可以利用 -m 来强制给予一个新的目录相关的权限， 例如上表当中，我们给予 -m 711 来给予新的目录 drwx--x--x 的权限。不过，如果没有给予 -m 选项时， 那么默认的新建目录权限又是什么呢？这个跟 umask 有关，我们在本章后头会加以介绍的。


rmdir (删除『空』的目录)
[root@www ~]# rmdir [-p] 目录名称
选项与参数：
-p ：连同上一级『空的』目录也一起删除

范例：将於mkdir范例中创建的目录(/tmp底下)删除掉！
[root@www tmp]# ls -l   <==看看有多少目录存在？
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
[root@www tmp]# rmdir test   <==可直接删除掉，没问题
[root@www tmp]# rmdir test1  <==因为尚有内容，所以无法删除！
rmdir: `test1': Directory not empty
[root@www tmp]# rmdir -p test1/test2/test3/test4
[root@www tmp]# ls -l        <==您看看，底下的输出中test与test1不见了！
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
# 瞧！利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除～
# 不过要注意的是，这个 rmdir 仅能『删除空的目录』喔！
如果想要删除旧有的目录时，就使用rmdir吧！例如将刚刚创建的test杀掉，使用『 rmdir test 』即可！请注意呦！目录需要一层一层的删除才行！而且被删除的目录里面必定不能存在其他的目录或文件！ 这也是所谓的空的目录(empty directory)的意思啊！那如果要将所有目录下的东西都杀掉呢？！ 这个时候就必须使用『 rm -r test 』罗！不过，还是使用 rmdir 比较不危险！你也可以尝试以 -p 的选项加入，来删除上一级的目录喔！

__关於运行档路径的变量： $PATH__
经过第六章FHS的说明后，我们知道查阅文件属性的命令ls完整档名为：/bin/ls(这是绝对路径)， 那你会不会觉得很奇怪：『为什么我可以在任何地方运行/bin/ls这个命令呢？ 』 为什么我在任何目录下输入 ls 就一定可以显示出一些信息而不会说找不到该 /bin/ls 命令呢？ 这是因为环境变量 PATH 的帮助所致呀！

当我们在运行一个命令的时候，举例来说『ls』好了，系统会依照PATH的配置去每个PATH定义的目录下搜寻档名为ls的可运行档， 如果在PATH定义的目录中含有多个档名为ls的可运行档，那么先搜寻到的同名命令先被运行！

现在，请下达『echo $PATH』来看看到底有哪些目录被定义出来了？ echo有『显示、印出』的意思，而 PATH 前面加的 $ 表示后面接的是变量，所以会显示出目前的 PATH ！

范例：先用root的身份列出搜寻的路径为何？
[root@www ~]# echo $PATH
/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin
:/bin:/usr/sbin:/usr/bin:/root/bin  <==这是同一行！

范例：用vbird的身份列出搜寻的路径为何？
[root@www ~]# su - vbird
[vbird@www ~]# echo $PATH
/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/home/vbird/bin
# 仔细看，一般用户vbird的PATH中，并不包含任何『sbin』的目录存在喔！
PATH(一定是大写)这个变量的内容是由一堆目录所组成的，每个目录中间用冒号(:)来隔开， 每个目录是有『顺序』之分的。仔细看一下上面的输出，你可以发现到无论是root还是vbird都有/bin 这个目录在PATH变量内，所以当然就能够在任何地方运行ls来找到/bin/ls运行档罗！

我们用几个范例来让你了解一下，为什么PATH是那么重要的项目！

例题：
请问你能不能使用一般身份使用者下达ifconfig eth0这个命令呢？
答：
如上面的范例所示，当你使用vbird这个帐号运行ifconfig时，会出现『-bash: ifconfig: command not found』的字样， 因为ifconfig的是放置到/sbin底下，而由上表的结果中我们可以发现vbird的PATH并没有配置/sbin， 所以默认无法运行。

但是你可以使用『/sbin/ifconfig eth0』来运行这个命令喔！因为一般用户还是可以使用ifconfig来查询系统IP的参数， 既然PATH没有规范到/sbin，那么我们使用『绝对路径』也可以运行到该命令的！

例题：
假设你是root，如果你将ls由/bin/ls移动成为/root/ls(可用『mv /bin/ls /root』命令达成)，然后你自己本身也在/root目录下， 请问(1)你能不能直接输入ls来运行？(2)若不能，你该如何运行ls这个命令？(3)若要直接输入ls即可运行，又该如何进行？
答：
由於这个例题的重点是将某个运行档移动到非正规目录去，所以我们先要进行底下的动作才行：(务必使用root的身份)
[root@www ~]# mv /bin/ls /root
# mv 为移动，可将文件在不同的目录间进行移动作业
(1)接下来不论你在那个目录底下输入任何与ls相关的命令，都没有办法顺利的运行ls了！ 也就是说，你不能直接输入ls来运行，因为/root这个目录并不在PATH指定的目录中， 所以，即使你在/root目录下，也不能够搜寻到ls这个命令！

(2)因为这个ls确实存在於/root底下，并不是被删除了！所以我们可以透过使用绝对路径或者是相对路径直接指定这个运行档档名， 底下的两个方法都能够运行ls这个命令：
[root@www ~]# /root/ls  <==直接用绝对路径指定该档名
[root@www ~]# ./ls      <==因为在 /root 目录下，就用./ls来指定
(3)如果想要让root在任何目录均可运行/root底下的ls，那么就将/root加入PATH当中即可。 加入的方法很简单，就像底下这样：
[root@www ~]# PATH="$PATH":/root
上面这个作法就能够将/root加入到运行档搜寻路径PATH中了！不相信的话请您自行使用『echo $PATH』去查看吧！ 如果确定这个例题进行没有问题了，请将ls搬回/bin底下，不然系统会挂点的！
[root@www ~]# mv /root/ls /bin

例题：
如果我有两个ls命令在不同的目录中，例如/usr/local/bin/ls与/bin/ls那么当我下达 ls 的时候，哪个ls会被运行？
答：
那还用说，就找出 PATH 里面哪个目录先被查询，则那个目录下的命令就会被先运行了！

例题：
为什么PATH搜寻的目录不加入本目录(.)？加入本目录的搜寻不是也不错？
答：
如果在PATH中加入本目录(.)后，确实我们就能够在命令所在目录进行命令的运行了。 但是由於你的工作目录并非固定(常常会使用cd来切换到不同的目录)， 因此能够运行的命令会有变动(因为每个目录底下的可运行档都不相同嘛！)，这对使用者来说并非好事。

另外，如果有个坏心使用者在/tmp底下做了一个命令，因为/tmp是大家都能够写入的环境，所以他当然可以这样做。 假设该命令可能会窃取使用者的一些数据，如果你使用root的身份来运行这个命令，那不是很糟糕？ 如果这个命令的名称又是经常会被用到的ls时，那『中标』的机率就更高了！

所以，为了安全起见，不建议将『.』加入PATH的搜寻目录中。

而由上面的几个例题我们也可以知道几件事情：

不同身份使用者默认的PATH不同，默认能够随意运行的命令也不同(如root与vbird)；
PATH是可以修改的，所以一般使用者还是可以透过修改PATH来运行某些位於/sbin或/usr/sbin下的命令来查询；
使用绝对路径或相对路径直接指定某个命令的档名来运行，会比搜寻PATH来的正确；
命令应该要放置到正确的目录下，运行才会比较方便；
本目录(.)最好不要放到PATH当中。
对於PATH更详细的『变量』说明，我们会在第三篇的bash shell中详细说明的！
